<roblox xmlns:xmime="http://www.w3.org/2005/05/xmlmime" xmlns:xsi="http://www.w3.org/2001/XMLSchema-instance" xsi:noNamespaceSchemaLocation="http://www.roblox.com/roblox.xsd" version="4">
	<External>null</External>
	<External>nil</External>
	<Item class="Workspace" referent="RBX96FF64C636794EB5A8D5802E90ED586F">
		<Properties>
			<bool name="AllowThirdPartySales">false</bool>
			<string name="CollisionGroups">Default^0^1</string>
			<Ref name="CurrentCamera">RBX1CDEAE6ED9984B56828BF508CA9E36E5</Ref>
			<double name="DistributedGameTime">0</double>
			<bool name="ExplicitAutoJoints">true</bool>
			<float name="FallenPartsDestroyHeight">-500</float>
			<bool name="FilteringEnabled">false</bool>
			<float name="Gravity">196.199997</float>
			<CoordinateFrame name="ModelInPrimary">
				<X>0</X>
				<Y>0</Y>
				<Z>0</Z>
				<R00>1</R00>
				<R01>0</R01>
				<R02>0</R02>
				<R10>0</R10>
				<R11>1</R11>
				<R12>0</R12>
				<R20>0</R20>
				<R21>0</R21>
				<R22>1</R22>
			</CoordinateFrame>
			<string name="Name">Workspace</string>
			<Ref name="PrimaryPart">null</Ref>
			<bool name="StreamingEnabled">false</bool>
			<int name="StreamingMinRadius">64</int>
			<token name="StreamingPauseMode">0</token>
			<int name="StreamingTargetRadius">1024</int>
			<BinaryString name="Tags"></BinaryString>
			<bool name="TemporaryLegacyPhysicsSolverOverrideStreaming">false</bool>
			<bool name="TerrainWeldsFixed">true</bool>
		</Properties>
		<Item class="Camera" referent="RBX1CDEAE6ED9984B56828BF508CA9E36E5">
			<Properties>
				<CoordinateFrame name="CFrame">
					<X>-0.818420529</X>
					<Y>30.5688534</Y>
					<Z>-83.0937729</Z>
					<R00>-0.968648314</R00>
					<R01>-0.1775105</R01>
					<R02>0.173812017</R02>
					<R10>-7.4505806e-09</R10>
					<R11>0.699624181</R11>
					<R12>0.714511156</R12>
					<R20>-0.248436287</R20>
					<R21>0.692110002</R21>
					<R22>-0.677689731</R22>
				</CoordinateFrame>
				<Ref name="CameraSubject">null</Ref>
				<token name="CameraType">0</token>
				<float name="FieldOfView">70</float>
				<CoordinateFrame name="Focus">
					<X>-1.166044</X>
					<Y>29.1398335</Y>
					<Z>-81.7383957</Z>
					<R00>1</R00>
					<R01>0</R01>
					<R02>0</R02>
					<R10>0</R10>
					<R11>1</R11>
					<R12>0</R12>
					<R20>0</R20>
					<R21>0</R21>
					<R22>1</R22>
				</CoordinateFrame>
				<bool name="HeadLocked">true</bool>
				<float name="HeadScale">1</float>
				<string name="Name">Camera</string>
				<BinaryString name="Tags"></BinaryString>
			</Properties>
		</Item>
		<Item class="Terrain" referent="RBXECF99FA4C1674D5C81BA03D0171A199E">
			<Properties>
				<bool name="Anchored">true</bool>
				<float name="BackParamA">-0.5</float>
				<float name="BackParamB">0.5</float>
				<token name="BackSurface">0</token>
				<token name="BackSurfaceInput">0</token>
				<float name="BottomParamA">-0.5</float>
				<float name="BottomParamB">0.5</float>
				<token name="BottomSurface">4</token>
				<token name="BottomSurfaceInput">0</token>
				<CoordinateFrame name="CFrame">
					<X>0</X>
					<Y>0</Y>
					<Z>0</Z>
					<R00>1</R00>
					<R01>0</R01>
					<R02>0</R02>
					<R10>0</R10>
					<R11>1</R11>
					<R12>0</R12>
					<R20>0</R20>
					<R21>0</R21>
					<R22>1</R22>
				</CoordinateFrame>
				<bool name="CanCollide">true</bool>
				<bool name="CastShadow">true</bool>
				<int name="CollisionGroupId">0</int>
				<Color3uint8 name="Color3uint8">4288914085</Color3uint8>
				<PhysicalProperties name="CustomPhysicalProperties">
					<CustomPhysics>false</CustomPhysics>
				</PhysicalProperties>
				<float name="FrontParamA">-0.5</float>
				<float name="FrontParamB">0.5</float>
				<token name="FrontSurface">0</token>
				<token name="FrontSurfaceInput">0</token>
				<float name="LeftParamA">-0.5</float>
				<float name="LeftParamB">0.5</float>
				<token name="LeftSurface">0</token>
				<token name="LeftSurfaceInput">0</token>
				<bool name="Locked">true</bool>
				<bool name="Massless">false</bool>
				<token name="Material">256</token>
				<BinaryString name="MaterialColors"><![CDATA[AAAAAAAAan8/P39rf2Y/ilY+j35fi21PZmxvZbDqw8faiVpHOi4kHh4lZlw76JxKc3trhHta
gcLgc4RKxr21zq2UlJSM]]></BinaryString>
				<string name="Name">Terrain</string>
				<BinaryString name="PhysicsGrid">AgMAAAAAAAAAAAAAAAA=</BinaryString>
				<float name="Reflectance">0</float>
				<float name="RightParamA">-0.5</float>
				<float name="RightParamB">0.5</float>
				<token name="RightSurface">0</token>
				<token name="RightSurfaceInput">0</token>
				<int name="RootPriority">0</int>
				<Vector3 name="RotVelocity">
					<X>0</X>
					<Y>0</Y>
					<Z>0</Z>
				</Vector3>
				<BinaryString name="SmoothGrid">AQU=</BinaryString>
				<BinaryString name="Tags"></BinaryString>
				<float name="TopParamA">-0.5</float>
				<float name="TopParamB">0.5</float>
				<token name="TopSurface">3</token>
				<token name="TopSurfaceInput">0</token>
				<float name="Transparency">0</float>
				<Vector3 name="Velocity">
					<X>0</X>
					<Y>0</Y>
					<Z>0</Z>
				</Vector3>
				<Color3 name="WaterColor">
					<R>0.0500000007</R>
					<G>0.330000013</G>
					<B>0.360000014</B>
				</Color3>
				<float name="WaterReflectance">1</float>
				<float name="WaterTransparency">0.300000012</float>
				<float name="WaterWaveSize">0.150000006</float>
				<float name="WaterWaveSpeed">10</float>
				<Vector3 name="size">
					<X>2044</X>
					<Y>252</Y>
					<Z>2044</Z>
				</Vector3>
			</Properties>
		</Item>
		<Item class="Part" referent="RBXF9BB57833B9045448260938B3C404C29">
			<Properties>
				<bool name="Anchored">true</bool>
				<float name="BackParamA">-0.5</float>
				<float name="BackParamB">0.5</float>
				<token name="BackSurface">0</token>
				<token name="BackSurfaceInput">0</token>
				<float name="BottomParamA">-0.5</float>
				<float name="BottomParamB">0.5</float>
				<token name="BottomSurface">0</token>
				<token name="BottomSurfaceInput">0</token>
				<CoordinateFrame name="CFrame">
					<X>0</X>
					<Y>0</Y>
					<Z>0</Z>
					<R00>1</R00>
					<R01>0</R01>
					<R02>0</R02>
					<R10>0</R10>
					<R11>1</R11>
					<R12>0</R12>
					<R20>0</R20>
					<R21>0</R21>
					<R22>1</R22>
				</CoordinateFrame>
				<bool name="CanCollide">true</bool>
				<bool name="CastShadow">true</bool>
				<int name="CollisionGroupId">0</int>
				<Color3uint8 name="Color3uint8">4284702562</Color3uint8>
				<PhysicalProperties name="CustomPhysicalProperties">
					<CustomPhysics>false</CustomPhysics>
				</PhysicalProperties>
				<float name="FrontParamA">-0.5</float>
				<float name="FrontParamB">0.5</float>
				<token name="FrontSurface">0</token>
				<token name="FrontSurfaceInput">0</token>
				<float name="LeftParamA">-0.5</float>
				<float name="LeftParamB">0.5</float>
				<token name="LeftSurface">0</token>
				<token name="LeftSurfaceInput">0</token>
				<bool name="Locked">true</bool>
				<bool name="Massless">false</bool>
				<token name="Material">256</token>
				<string name="Name">Part</string>
				<float name="Reflectance">0</float>
				<float name="RightParamA">-0.5</float>
				<float name="RightParamB">0.5</float>
				<token name="RightSurface">0</token>
				<token name="RightSurfaceInput">0</token>
				<int name="RootPriority">0</int>
				<Vector3 name="RotVelocity">
					<X>0</X>
					<Y>0</Y>
					<Z>0</Z>
				</Vector3>
				<BinaryString name="Tags"></BinaryString>
				<float name="TopParamA">-0.5</float>
				<float name="TopParamB">0.5</float>
				<token name="TopSurface">3</token>
				<token name="TopSurfaceInput">0</token>
				<float name="Transparency">0</float>
				<Vector3 name="Velocity">
					<X>0</X>
					<Y>0</Y>
					<Z>0</Z>
				</Vector3>
				<token name="formFactorRaw">1</token>
				<token name="shape">1</token>
				<Vector3 name="size">
					<X>521</X>
					<Y>30</Y>
					<Z>521</Z>
				</Vector3>
			</Properties>
		</Item>
	</Item>
	<Item class="SoundService" referent="RBXE76E0662D9474FA38A2EF9B530682CDF">
		<Properties>
			<token name="AmbientReverb">0</token>
			<float name="DistanceFactor">3.32999992</float>
			<float name="DopplerScale">1</float>
			<string name="Name">SoundService</string>
			<bool name="RespectFilteringEnabled">false</bool>
			<float name="RolloffScale">1</float>
			<BinaryString name="Tags"></BinaryString>
		</Properties>
	</Item>
	<Item class="NonReplicatedCSGDictionaryService" referent="RBX6AAD975963D14139882C777F9AAFEE54">
		<Properties>
			<string name="Name">NonReplicatedCSGDictionaryService</string>
			<BinaryString name="Tags"></BinaryString>
		</Properties>
	</Item>
	<Item class="CSGDictionaryService" referent="RBXA6848AA964E643CF98761F0073768FDF">
		<Properties>
			<string name="Name">CSGDictionaryService</string>
			<BinaryString name="Tags"></BinaryString>
		</Properties>
	</Item>
	<Item class="Chat" referent="RBXE6A20F03D6124901B4FCD878CAB94554">
		<Properties>
			<bool name="BubbleChatEnabled">false</bool>
			<bool name="LoadDefaultChat">true</bool>
			<string name="Name">Chat</string>
			<BinaryString name="Tags"></BinaryString>
		</Properties>
	</Item>
	<Item class="TimerService" referent="RBXB4CB43BF75C14A478F2DAC2F98939B06">
		<Properties>
			<string name="Name">Instance</string>
			<BinaryString name="Tags"></BinaryString>
		</Properties>
	</Item>
	<Item class="Players" referent="RBXCF34724C97AA415FAF6BF5D4A74871AD">
		<Properties>
			<bool name="CharacterAutoLoads">true</bool>
			<int name="MaxPlayersInternal">12</int>
			<string name="Name">Players</string>
			<int name="PreferredPlayersInternal">0</int>
			<float name="RespawnTime">5</float>
			<BinaryString name="Tags"></BinaryString>
		</Properties>
	</Item>
	<Item class="ReplicatedFirst" referent="RBX0E8DE65282C94D84AB87B88D1CC32492">
		<Properties>
			<string name="Name">ReplicatedFirst</string>
			<BinaryString name="Tags"></BinaryString>
		</Properties>
	</Item>
	<Item class="TweenService" referent="RBX9E107B2F7B6544D188836C1D024BBF8B">
		<Properties>
			<string name="Name">TweenService</string>
			<BinaryString name="Tags"></BinaryString>
		</Properties>
	</Item>
	<Item class="StarterPlayer" referent="9">
		<Properties>
			<bool name="AllowCustomAnimations">true</bool>
			<bool name="AutoJumpEnabled">true</bool>
			<float name="CameraMaxZoomDistance">400</float>
			<float name="CameraMinZoomDistance">0.5</float>
			<token name="CameraMode">0</token>
			<float name="CharacterJumpHeight">7.19999981</float>
			<float name="CharacterJumpPower">50</float>
			<float name="CharacterMaxSlopeAngle">89</float>
			<bool name="CharacterUseJumpPower">true</bool>
			<float name="CharacterWalkSpeed">16</float>
			<token name="DevCameraOcclusionMode">0</token>
			<token name="DevComputerCameraMovementMode">0</token>
			<token name="DevComputerMovementMode">0</token>
			<token name="DevTouchCameraMovementMode">0</token>
			<token name="DevTouchMovementMode">0</token>
			<bool name="EnableMouseLockOption">true</bool>
			<int64 name="GameSettingsAssetIDFace">0</int64>
			<int64 name="GameSettingsAssetIDHead">0</int64>
			<int64 name="GameSettingsAssetIDLeftArm">0</int64>
			<int64 name="GameSettingsAssetIDLeftLeg">0</int64>
			<int64 name="GameSettingsAssetIDPants">0</int64>
			<int64 name="GameSettingsAssetIDRightArm">0</int64>
			<int64 name="GameSettingsAssetIDRightLeg">0</int64>
			<int64 name="GameSettingsAssetIDShirt">0</int64>
			<int64 name="GameSettingsAssetIDTeeShirt">0</int64>
			<int64 name="GameSettingsAssetIDTorso">0</int64>
			<token name="GameSettingsAvatar">1</token>
			<token name="GameSettingsR15Collision">0</token>
			<NumberRange name="GameSettingsScaleRangeBodyType">0 1 </NumberRange>
			<NumberRange name="GameSettingsScaleRangeHead">0.95 1 </NumberRange>
			<NumberRange name="GameSettingsScaleRangeHeight">0.9 1.05 </NumberRange>
			<NumberRange name="GameSettingsScaleRangeProportion">0 1 </NumberRange>
			<NumberRange name="GameSettingsScaleRangeWidth">0.7 1 </NumberRange>
			<float name="HealthDisplayDistance">100</float>
			<bool name="LoadCharacterAppearance">true</bool>
			<string name="Name">StarterPlayer</string>
			<float name="NameDisplayDistance">100</float>
			<BinaryString name="Tags"></BinaryString>
			<bool name="UserEmotesEnabled">true</bool>
		</Properties>
		<Item class="StarterPlayerScripts" referent="10">
			<Properties>
				<string name="Name">StarterPlayerScripts</string>
				<BinaryString name="Tags"></BinaryString>
			</Properties>
			<Item class="Folder" referent="11">
				<Properties>
					<string name="Name">TS</string>
					<BinaryString name="Tags"></BinaryString>
				</Properties>
				<Item class="LocalScript" referent="12">
					<Properties>
						<bool name="Disabled">false</bool>
						<Content name="LinkedSource"><null></null></Content>
						<string name="Name">main</string>
						<string name="ScriptGuid">{B0153CC3-6C83-4B8C-8D71-C81EFC2F209D}</string>
						<ProtectedString name="Source"><![CDATA[-- Compiled with https://roblox-ts.github.io v0.2.14
-- August 26, 2019, 6:16 PM British Summer Time

local TS = require(game:GetService("ReplicatedStorage"):WaitForChild("rbxts_include"):WaitForChild("RuntimeLib"));
local mount = TS.import(script.Parent, "roactUI", "module").default;
mount();
]]></ProtectedString>
						<BinaryString name="Tags"></BinaryString>
					</Properties>
				</Item>
				<Item class="Folder" referent="RBX7B9F78132E5C4F85BB17336C6A0FC2F6">
					<Properties>
						<string name="Name">roactUI</string>
						<BinaryString name="Tags"></BinaryString>
					</Properties>
					<Item class="Folder" referent="RBX10E1CAAFF940422C97231C29D0D889C1">
						<Properties>
							<string name="Name">components</string>
							<BinaryString name="Tags"></BinaryString>
						</Properties>
						<Item class="Folder" referent="RBX487E8F99FEA04D3CB84B1F7BF1FE3922">
							<Properties>
								<string name="Name">checkbox</string>
								<BinaryString name="Tags"></BinaryString>
							</Properties>
							<Item class="ModuleScript" referent="RBX5B5B35548EAC463CB16689BEA99D1744">
								<Properties>
									<Content name="LinkedSource"><null></null></Content>
									<string name="Name">module</string>
									<string name="ScriptGuid">{9D4D7BF2-510F-4EA9-90E5-BD4CEF312D7D}</string>
									<ProtectedString name="Source"><![CDATA[-- Compiled with https://roblox-ts.github.io v0.2.14
-- August 26, 2019, 6:16 PM British Summer Time

local TS = require(game:GetService("ReplicatedStorage"):WaitForChild("rbxts_include"):WaitForChild("RuntimeLib"));
local exports = {};
local Roact = TS.import(TS.getModule("roact").roact.src);
local Tween = TS.import(TS.getModule("tween")).default;
local OutElastic = TS.import(TS.getModule("easing-functions")).OutElastic;
local Toggle;
do
	Toggle = Roact.Component:extend("Toggle");
	function Toggle:init(props)
		self.updatePositions = TS.async(function(toggled)
			local ticked = self.tickRef:getValue();
			local minus = self.minusRef:getValue();
			local background = self.backgroundRef:getValue();
			if ticked and background and minus then
				if toggled then
					Tween(.2, OutElastic, function(x)
						local _0 = x;
						background.ImageColor3 = _0;
						return _0;
					end, background.ImageColor3, Color3.fromRGB(0, 197, 137), 0.5, 0.5);
					minus:TweenSizeAndPosition(UDim2.new(0, 0, 0, 0), UDim2.new(0.5, 0, 0.5, 0), Enum.EasingDirection.Out, Enum.EasingStyle.Linear, .1, true, function()
						ticked:TweenSizeAndPosition(UDim2.new(0.7, 0, 0.7, 0), UDim2.new(0.15, 0, 0.15, 0), Enum.EasingDirection.Out, Enum.EasingStyle.Linear, .1, true, function()
							return self:setState({
								animating = false;
							});
						end);
					end);
				else
					Tween(.2, OutElastic, function(x)
						local _0 = x;
						background.ImageColor3 = _0;
						return _0;
					end, background.ImageColor3, Color3.fromRGB(240, 240, 240), 0.5, 0.5);
					ticked:TweenSizeAndPosition(UDim2.new(0, 0, 0, 0), UDim2.new(0.5, 0, 0.5, 0), Enum.EasingDirection.Out, Enum.EasingStyle.Linear, .1, true, function()
						minus:TweenSizeAndPosition(UDim2.new(0.7, 0, 0.2, 0), UDim2.new(0.15, 0, 0.4, 0), Enum.EasingDirection.Out, Enum.EasingStyle.Linear, .1, true, function()
							return self:setState({
								animating = false;
							});
						end);
					end);
				end;
			end;
		end);
		self.clicked = function()
			if not self.props.disabled and not self.state.animating then
				self.updatePositions(not self.state.toggled);
				self:setState({
					toggled = not self.state.toggled;
					animating = true;
				});
			end;
		end;
		self.showText = function()
			print(self.props.text);
			if self.props.text then
				return Roact.createElement("Frame", {
					Size = UDim2.new(0.6, 0, 1, 0),
					BackgroundTransparency = 1 
				}				, {
					Roact.createElement("UIListLayout", {
						VerticalAlignment = Enum.VerticalAlignment.Center,
						HorizontalAlignment = Enum.HorizontalAlignment.Center,
						FillDirection = Enum.FillDirection.Vertical 
					}),
					Roact.createElement("TextLabel", {
						Text = self.props.text,
						BackgroundTransparency = 1,
						TextScaled = true,
						TextWrapped = false,
						TextXAlignment = Enum.TextXAlignment.Left,
						Size = UDim2.new(1, 0, .25, 0),
						TextColor3 = Color3.fromRGB(35, 35, 35) 
					})
				});
			end;
		end;
		self:setState({
			toggled = self.props.toggled;
			animating = false;
		});
		self.backgroundRef = Roact.createRef();
		self.tickRef = Roact.createRef();
		self.minusRef = Roact.createRef();
		self.updatePositions(self.props.toggled);
	end;
	function Toggle:didUpdate(previousProps, previousState)
		if previousState.toggled ~= self.state.toggled then
		end;
	end;
	function Toggle:render()
		print("props", self.props.text);
				local _0;
				if self.props.text then
					_0 = UDim2.new(0.25, 0, 1, 0);
				else
					_0 = UDim2.new(1, 0, 1, 0);
				end;
				local _1;
				if self.props.text then
					_1 = UDim2.new(0.65, 0, 0, 0);
				else
					_1 = UDim2.new(0, 0, 0, 0);
				end;
		return Roact.createElement("Frame", {
			BackgroundTransparency = 1,
			Position = UDim2.new(0, 0, 0, 0),
			Size = self.props.size 
		}, TS.Roact_combine({
					Roact.createElement("Frame", {
				BackgroundTransparency = 1,
				Size = _0,
				Position = _1 
			}			, {
				Roact.createElement("UIListLayout", {
					VerticalAlignment = Enum.VerticalAlignment.Center,
					HorizontalAlignment = Enum.HorizontalAlignment.Center,
					FillDirection = Enum.FillDirection.Vertical 
				}),
				Roact.createElement("Frame", {
					Size = UDim2.new(1, 0, 0.75, 0),
					BackgroundTransparency = 1 
				}				, {
					Roact.createElement("UIAspectRatioConstraint", {}),
					Roact.createElement("ImageButton", {
						Image = "rbxassetid://3704104427",
						ImageColor3 = Color3.fromRGB(101, 175, 168),
						AutoButtonColor = false,
						BackgroundTransparency = 1,
						Size = UDim2.new(1, 0, 1, 0),
						[Roact.Event.MouseButton1Click] = self.clicked,
						[Roact.Ref] = self.backgroundRef 
					}					, {
						["tick"] = Roact.createElement("ImageButton", {
							Image = "rbxassetid://3704097797",
							BackgroundTransparency = 1,
							Position = UDim2.new(0.15, 0, 0.15, 0),
							Size = UDim2.new(0, 0, 0, 0),
							[Roact.Event.MouseButton1Click] = self.clicked,
							[Roact.Ref] = self.tickRef 
						}),
						["minus"] = Roact.createElement("ImageButton", {
							Image = "rbxassetid://3704097997",
							BackgroundTransparency = 1,
							Position = UDim2.new(0.15, 0, 0.45, 0),
							Size = UDim2.new(0.7, 0, 0.1, 0),
							[Roact.Event.MouseButton1Click] = self.clicked,
							[Roact.Ref] = self.minusRef 
						})
					})
				})
			})
		}, 
			{ self.showText() }
		));
	end;
end;
exports.default = Toggle;
return exports;
]]></ProtectedString>
									<BinaryString name="Tags"></BinaryString>
								</Properties>
							</Item>
						</Item>
						<Item class="Folder" referent="RBX21713E8EFF644AE2BFC4F3D2A3827D36">
							<Properties>
								<string name="Name">settings</string>
								<BinaryString name="Tags"></BinaryString>
							</Properties>
							<Item class="ModuleScript" referent="RBX6D2A1DF2CD4A49688D3326AF36F76B30">
								<Properties>
									<Content name="LinkedSource"><null></null></Content>
									<string name="Name">module</string>
									<string name="ScriptGuid">{8A395CB7-3904-4975-86DC-BFC832DB373A}</string>
									<ProtectedString name="Source"><![CDATA[-- Compiled with https://roblox-ts.github.io v0.2.14
-- August 26, 2019, 6:16 PM British Summer Time

local TS = require(game:GetService("ReplicatedStorage"):WaitForChild("rbxts_include"):WaitForChild("RuntimeLib"));
local exports = {};
local Roact = TS.import(TS.getModule("roact").roact.src);
local Toggle = TS.import(script.Parent.Parent, "toggle", "module").default;
local Checkbox = TS.import(script.Parent.Parent, "checkbox", "module").default;
local function Base(props)
	return Roact.createElement("Frame", {
		Size = UDim2.new(1, 0, 1, 0),
		BackgroundTransparency = 1 
	}	, {
		Roact.createElement("UIListLayout", {}),
		Roact.createElement(Checkbox, {
			text = "Check Check Roger",
			disabled = false,
			toggled = false,
			change = function()
				print("3");
			end,
			size = UDim2.new(0.5, 0, 0, 100) 
		}),
		Roact.createElement(Toggle, {
			disabled = false,
			toggled = true,
			change = function()
				print("3");
			end 
		})
	});
end;
exports.default = Base;
return exports;
]]></ProtectedString>
									<BinaryString name="Tags"></BinaryString>
								</Properties>
							</Item>
						</Item>
						<Item class="Folder" referent="RBX55AE81CEDBE94DB6B118140D7A232678">
							<Properties>
								<string name="Name">toggle</string>
								<BinaryString name="Tags"></BinaryString>
							</Properties>
							<Item class="ModuleScript" referent="RBX9D52DAFD29BE4D6D92F319347F06A8BD">
								<Properties>
									<Content name="LinkedSource"><null></null></Content>
									<string name="Name">module</string>
									<string name="ScriptGuid">{1A6BEB70-C83C-44BA-8259-BA1EDCBB6A3E}</string>
									<ProtectedString name="Source"><![CDATA[-- Compiled with https://roblox-ts.github.io v0.2.14
-- August 26, 2019, 6:16 PM British Summer Time

local TS = require(game:GetService("ReplicatedStorage"):WaitForChild("rbxts_include"):WaitForChild("RuntimeLib"));
local exports = {};
local Roact = TS.import(TS.getModule("roact").roact.src);
local Tween = TS.import(TS.getModule("tween")).default;
local OutElastic = TS.import(TS.getModule("easing-functions")).OutElastic;
local Toggle;
do
	Toggle = Roact.Component:extend("Toggle");
	function Toggle:init(props)
		self.updatePositions = TS.async(function(toggled)
			local toggle = self.sliderRef:getValue();
			local background = self.backgroundRef:getValue();
			if toggle and background then
				local _0;
				if toggled then
					_0 = 0.5;
				else
					_0 = 0;
				end;
				toggle:TweenPosition(UDim2.new(_0, 0, 0, 0), Enum.EasingDirection.Out, Enum.EasingStyle.Linear, .2, true, function()
					self:setState({
						animating = false;
					});
				end);
				if toggled then
					Tween(.2, OutElastic, function(x)
						local _1 = x;
						background.ImageColor3 = _1;
						return _1;
					end, background.ImageColor3, Color3.fromRGB(0, 197, 137), 0.5, 0.5);
				else
					Tween(.2, OutElastic, function(x)
						local _1 = x;
						background.ImageColor3 = _1;
						return _1;
					end, background.ImageColor3, Color3.fromRGB(255, 255, 255), 0.5, 0.5);
				end;
			end;
		end);
		self.clicked = function()
			if not self.props.disabled and not self.state.animating then
				self.updatePositions(not self.state.toggled);
				self:setState({
					toggled = not self.state.toggled;
					animating = true;
				});
			end;
		end;
		self:setState({
			toggled = self.props.toggled;
			animating = false;
		});
		self.sliderRef = Roact.createRef();
		self.backgroundRef = Roact.createRef();
		self.updatePositions(self.props.toggled);
	end;
	function Toggle:didUpdate(previousProps, previousState)
		if previousState.toggled ~= self.state.toggled then
		end;
	end;
	function Toggle:render()
		return Roact.createElement("Frame", {
			BackgroundTransparency = 1,
			Size = UDim2.new(0, 275, 0, 128) 
		}		, {
			Roact.createElement("ImageButton", {
				Image = "rbxassetid://3695679569",
				BackgroundTransparency = 1,
				Size = UDim2.new(1, 0, 1, 0),
				[Roact.Event.MouseButton1Click] = self.clicked,
				[Roact.Ref] = self.backgroundRef 
			}			, {
				["slider"] = Roact.createElement("ImageButton", {
					Image = "rbxassetid://3695699299",
					ImageColor3 = Color3.fromRGB(240, 240, 240),
					BackgroundTransparency = 1,
					Size = UDim2.new(0.9, 0, 1.1, 0),
					[Roact.Event.MouseButton1Click] = self.clicked,
					[Roact.Ref] = self.sliderRef 
				}				, {
					Roact.createElement("UIAspectRatioConstraint", {})
				}),
				["border"] = Roact.createElement("ImageButton", {
					Image = "rbxassetid://3695646888",
					ImageColor3 = Color3.fromRGB(134, 0, 2),
					ImageTransparency = 1,
					BackgroundTransparency = 1,
					Size = UDim2.new(1, 0, 1, 0),
					[Roact.Event.MouseButton1Click] = self.clicked 
				})
			})
		});
	end;
end;
exports.default = Toggle;
return exports;
]]></ProtectedString>
									<BinaryString name="Tags"></BinaryString>
								</Properties>
							</Item>
						</Item>
						<Item class="Folder" referent="RBX6C3ADA5412C7422F8556CA80CBBD9ADC">
							<Properties>
								<string name="Name">views</string>
								<BinaryString name="Tags"></BinaryString>
							</Properties>
							<Item class="Folder" referent="RBX5F6BFE9BA72449B69E7B7D56C4462F55">
								<Properties>
									<string name="Name">loading</string>
									<BinaryString name="Tags"></BinaryString>
								</Properties>
								<Item class="ModuleScript" referent="RBXBF0371B9A2AD414C9D21A581D87C4D17">
									<Properties>
										<Content name="LinkedSource"><null></null></Content>
										<string name="Name">module</string>
										<string name="ScriptGuid">{D834812C-0C97-4E9E-8646-21DB9796B14E}</string>
										<ProtectedString name="Source"><![CDATA[-- Compiled with https://roblox-ts.github.io v0.2.14
-- August 26, 2019, 6:16 PM British Summer Time

local TS = require(game:GetService("ReplicatedStorage"):WaitForChild("rbxts_include"):WaitForChild("RuntimeLib"));
local exports = {};
local Roact = TS.import(TS.getModule("roact").roact.src);
local function Toggle()
	return Roact.createElement("Frame", {
		Size = UDim2.new(1, 0, 1, 0) 
	}	, {
		Roact.createElement("Frame", {
			Size = UDim2.new(1, 0, 1, 0) 
		}		, {
			Roact.createElement("TextLabel", {
				Text = "PROJECT METROS",
				BorderSizePixel = 0,
				BackgroundTransparency = 1 
			})
		})
	});
end;
exports.default = Toggle;
return exports;
]]></ProtectedString>
										<BinaryString name="Tags"></BinaryString>
									</Properties>
								</Item>
							</Item>
						</Item>
					</Item>
					<Item class="ModuleScript" referent="RBX53ABE1274780483392A50C574350ACC2">
						<Properties>
							<Content name="LinkedSource"><null></null></Content>
							<string name="Name">module</string>
							<string name="ScriptGuid">{8DE11732-ADB9-428B-AE1A-6E255F43CB06}</string>
							<ProtectedString name="Source"><![CDATA[-- Compiled with https://roblox-ts.github.io v0.2.14
-- August 26, 2019, 6:16 PM British Summer Time

local TS = require(game:GetService("ReplicatedStorage"):WaitForChild("rbxts_include"):WaitForChild("RuntimeLib"));
local exports = {};
local Roact = TS.import(TS.getModule("roact").roact.src);
local Settings = TS.import(script.Parent, "components", "settings", "module").default;
local LocalPlayer = game:GetService("Players").LocalPlayer;
local PlayerGui = LocalPlayer:FindFirstChildOfClass("PlayerGui");
local function Base(props)
	return Roact.createElement("ScreenGui", {}	, {
		Roact.createElement("TextLabel", {
			Text = props.name 
		}),
		Roact.createElement("Frame", {
			Size = UDim2.new(1, 0, 1, 0),
			Position = UDim2.new(0, 0, 0, 0),
			Transparency = 1 
		}		, {
			Roact.createElement(Settings, {
				name = "hot sauce" 
			})
		})
	});
end;
print("yote");
local function mount()
	local comp = Roact.createElement(Base, {
		name = "YEET";
	});
	Roact.mount(comp, PlayerGui);
end;
exports.default = mount;
return exports;
]]></ProtectedString>
							<BinaryString name="Tags"></BinaryString>
						</Properties>
					</Item>
				</Item>
			</Item>
		</Item>
		<Item class="StarterCharacterScripts" referent="RBXC62C64EA9EF84AE4BA2819378BC9C3DE">
			<Properties>
				<string name="Name">StarterCharacterScripts</string>
				<BinaryString name="Tags"></BinaryString>
			</Properties>
		</Item>
	</Item>
	<Item class="StarterPack" referent="RBXCADA35B0766A4C0FAE65D9E9DA9EE888">
		<Properties>
			<string name="Name">StarterPack</string>
			<BinaryString name="Tags"></BinaryString>
		</Properties>
	</Item>
	<Item class="StarterGui" referent="RBX0719147A9C104E378EAA97349D30F897">
		<Properties>
			<string name="Name">StarterGui</string>
			<bool name="ResetPlayerGuiOnSpawn">true</bool>
			<token name="ScreenOrientation">2</token>
			<bool name="ShowDevelopmentGui">true</bool>
			<BinaryString name="Tags"></BinaryString>
		</Properties>
		<Item class="ScreenGui" referent="RBX65389343F15142BEA8B67905509FA28E">
			<Properties>
				<bool name="AutoLocalize">true</bool>
				<int name="DisplayOrder">0</int>
				<bool name="Enabled">true</bool>
				<bool name="IgnoreGuiInset">false</bool>
				<string name="Name">ScreenGui</string>
				<bool name="ResetOnSpawn">true</bool>
				<Ref name="RootLocalizationTable">null</Ref>
				<BinaryString name="Tags"></BinaryString>
				<token name="ZIndexBehavior">1</token>
			</Properties>
			<Item class="Frame" referent="RBXCA8B26F0BDE646C1AD0DB976C2C8429F">
				<Properties>
					<bool name="Active">false</bool>
					<Vector2 name="AnchorPoint">
						<X>0</X>
						<Y>0</Y>
					</Vector2>
					<bool name="AutoLocalize">true</bool>
					<Color3 name="BackgroundColor3">
						<R>1</R>
						<G>1</G>
						<B>1</B>
					</Color3>
					<float name="BackgroundTransparency">1</float>
					<Color3 name="BorderColor3">
						<R>0.105882362</R>
						<G>0.164705887</G>
						<B>0.207843155</B>
					</Color3>
					<token name="BorderMode">0</token>
					<int name="BorderSizePixel">1</int>
					<bool name="ClipsDescendants">false</bool>
					<bool name="Draggable">false</bool>
					<int name="LayoutOrder">0</int>
					<string name="Name">Frame</string>
					<Ref name="NextSelectionDown">null</Ref>
					<Ref name="NextSelectionLeft">null</Ref>
					<Ref name="NextSelectionRight">null</Ref>
					<Ref name="NextSelectionUp">null</Ref>
					<UDim2 name="Position">
						<XS>0</XS>
						<XO>0</XO>
						<YS>0.235999972</YS>
						<YO>0</YO>
					</UDim2>
					<Ref name="RootLocalizationTable">null</Ref>
					<float name="Rotation">0</float>
					<bool name="Selectable">false</bool>
					<Ref name="SelectionImageObject">null</Ref>
					<UDim2 name="Size">
						<XS>0</XS>
						<XO>621</XO>
						<YS>0</YS>
						<YO>267</YO>
					</UDim2>
					<token name="SizeConstraint">0</token>
					<token name="Style">0</token>
					<BinaryString name="Tags"></BinaryString>
					<bool name="Visible">true</bool>
					<int name="ZIndex">1</int>
				</Properties>
				<Item class="ImageLabel" referent="RBX717378072FDE4F628B5FA2157C9191CF">
					<Properties>
						<bool name="Active">false</bool>
						<Vector2 name="AnchorPoint">
							<X>0</X>
							<Y>0</Y>
						</Vector2>
						<bool name="AutoLocalize">true</bool>
						<Color3 name="BackgroundColor3">
							<R>0.819607913</R>
							<G>0.819607913</G>
							<B>0.819607913</B>
						</Color3>
						<float name="BackgroundTransparency">1</float>
						<Color3 name="BorderColor3">
							<R>0.105882362</R>
							<G>0.164705887</G>
							<B>0.207843155</B>
						</Color3>
						<token name="BorderMode">0</token>
						<int name="BorderSizePixel">1</int>
						<bool name="ClipsDescendants">false</bool>
						<bool name="Draggable">false</bool>
						<Content name="Image"><url>rbxassetid://3737268745</url></Content>
						<Color3 name="ImageColor3">
							<R>0.819607913</R>
							<G>0.819607913</G>
							<B>0.819607913</B>
						</Color3>
						<Vector2 name="ImageRectOffset">
							<X>0</X>
							<Y>0</Y>
						</Vector2>
						<Vector2 name="ImageRectSize">
							<X>0</X>
							<Y>0</Y>
						</Vector2>
						<float name="ImageTransparency">0</float>
						<int name="LayoutOrder">0</int>
						<string name="Name">ImageLabel</string>
						<Ref name="NextSelectionDown">null</Ref>
						<Ref name="NextSelectionLeft">null</Ref>
						<Ref name="NextSelectionRight">null</Ref>
						<Ref name="NextSelectionUp">null</Ref>
						<UDim2 name="Position">
							<XS>0.50080508</XS>
							<XO>0</XO>
							<YS>1.24654543</YS>
							<YO>0</YO>
						</UDim2>
						<Ref name="RootLocalizationTable">null</Ref>
						<float name="Rotation">0</float>
						<token name="ScaleType">0</token>
						<bool name="Selectable">false</bool>
						<Ref name="SelectionImageObject">null</Ref>
						<UDim2 name="Size">
							<XS>1.94412422</XS>
							<XO>0</XO>
							<YS>1.94566596</YS>
							<YO>0</YO>
						</UDim2>
						<token name="SizeConstraint">0</token>
						<Rect2D name="SliceCenter">
							<min>
								<X>0</X>
								<Y>0</Y>
							</min>
							<max>
								<X>0</X>
								<Y>0</Y>
							</max>
						</Rect2D>
						<float name="SliceScale">1</float>
						<BinaryString name="Tags"></BinaryString>
						<UDim2 name="TileSize">
							<XS>1</XS>
							<XO>0</XO>
							<YS>1</YS>
							<YO>0</YO>
						</UDim2>
						<bool name="Visible">true</bool>
						<int name="ZIndex">1</int>
					</Properties>
					<Item class="ImageButton" referent="RBX46BB107108F947DC8DF8C0E7F85FF7B6">
						<Properties>
							<bool name="Active">true</bool>
							<Vector2 name="AnchorPoint">
								<X>0</X>
								<Y>0</Y>
							</Vector2>
							<bool name="AutoButtonColor">true</bool>
							<bool name="AutoLocalize">true</bool>
							<Color3 name="BackgroundColor3">
								<R>1</R>
								<G>1</G>
								<B>1</B>
							</Color3>
							<float name="BackgroundTransparency">1</float>
							<Color3 name="BorderColor3">
								<R>0.105882362</R>
								<G>0.164705887</G>
								<B>0.207843155</B>
							</Color3>
							<token name="BorderMode">0</token>
							<int name="BorderSizePixel">1</int>
							<bool name="ClipsDescendants">false</bool>
							<bool name="Draggable">false</bool>
							<Content name="HoverImage"><null></null></Content>
							<Content name="Image"><url>rbxassetid://3737287170</url></Content>
							<Color3 name="ImageColor3">
								<R>1</R>
								<G>1</G>
								<B>1</B>
							</Color3>
							<Vector2 name="ImageRectOffset">
								<X>0</X>
								<Y>0</Y>
							</Vector2>
							<Vector2 name="ImageRectSize">
								<X>0</X>
								<Y>0</Y>
							</Vector2>
							<float name="ImageTransparency">0</float>
							<int name="LayoutOrder">0</int>
							<bool name="Modal">false</bool>
							<string name="Name">fab</string>
							<Ref name="NextSelectionDown">null</Ref>
							<Ref name="NextSelectionLeft">null</Ref>
							<Ref name="NextSelectionRight">null</Ref>
							<Ref name="NextSelectionUp">null</Ref>
							<UDim2 name="Position">
								<XS>0.391565889</XS>
								<XO>0</XO>
								<YS>0.5</YS>
								<YO>0</YO>
							</UDim2>
							<Content name="PressedImage"><null></null></Content>
							<Ref name="RootLocalizationTable">null</Ref>
							<float name="Rotation">0</float>
							<token name="ScaleType">0</token>
							<bool name="Selectable">true</bool>
							<bool name="Selected">false</bool>
							<Ref name="SelectionImageObject">null</Ref>
							<UDim2 name="Size">
								<XS>1</XS>
								<XO>0</XO>
								<YS>0.5</YS>
								<YO>0</YO>
							</UDim2>
							<token name="SizeConstraint">0</token>
							<Rect2D name="SliceCenter">
								<min>
									<X>0</X>
									<Y>0</Y>
								</min>
								<max>
									<X>0</X>
									<Y>0</Y>
								</max>
							</Rect2D>
							<float name="SliceScale">1</float>
							<token name="Style">0</token>
							<BinaryString name="Tags"></BinaryString>
							<UDim2 name="TileSize">
								<XS>1</XS>
								<XO>0</XO>
								<YS>1</YS>
								<YO>0</YO>
							</UDim2>
							<bool name="Visible">true</bool>
							<int name="ZIndex">1</int>
						</Properties>
						<Item class="UIAspectRatioConstraint" referent="RBX0F23753309D349EEBE38EDF54FC31D20">
							<Properties>
								<float name="AspectRatio">1</float>
								<token name="AspectType">0</token>
								<token name="DominantAxis">1</token>
								<string name="Name">UIAspectRatioConstraint</string>
								<BinaryString name="Tags"></BinaryString>
							</Properties>
						</Item>
						<Item class="ImageButton" referent="RBX02F2DAF1E1254FCCB089016C85881DBD">
							<Properties>
								<bool name="Active">true</bool>
								<Vector2 name="AnchorPoint">
									<X>0</X>
									<Y>0</Y>
								</Vector2>
								<bool name="AutoButtonColor">true</bool>
								<bool name="AutoLocalize">true</bool>
								<Color3 name="BackgroundColor3">
									<R>1</R>
									<G>1</G>
									<B>1</B>
								</Color3>
								<float name="BackgroundTransparency">1</float>
								<Color3 name="BorderColor3">
									<R>0.105882362</R>
									<G>0.164705887</G>
									<B>0.207843155</B>
								</Color3>
								<token name="BorderMode">0</token>
								<int name="BorderSizePixel">1</int>
								<bool name="ClipsDescendants">false</bool>
								<bool name="Draggable">false</bool>
								<Content name="HoverImage"><null></null></Content>
								<Content name="Image"><url>rbxassetid://3737657351</url></Content>
								<Color3 name="ImageColor3">
									<R>1</R>
									<G>1</G>
									<B>1</B>
								</Color3>
								<Vector2 name="ImageRectOffset">
									<X>0</X>
									<Y>0</Y>
								</Vector2>
								<Vector2 name="ImageRectSize">
									<X>0</X>
									<Y>0</Y>
								</Vector2>
								<float name="ImageTransparency">0</float>
								<int name="LayoutOrder">0</int>
								<bool name="Modal">false</bool>
								<string name="Name">ImageButton</string>
								<Ref name="NextSelectionDown">null</Ref>
								<Ref name="NextSelectionLeft">null</Ref>
								<Ref name="NextSelectionRight">null</Ref>
								<Ref name="NextSelectionUp">null</Ref>
								<UDim2 name="Position">
									<XS>0.2733033</XS>
									<XO>0</XO>
									<YS>0.203316405</YS>
									<YO>0</YO>
								</UDim2>
								<Content name="PressedImage"><null></null></Content>
								<Ref name="RootLocalizationTable">null</Ref>
								<float name="Rotation">0</float>
								<token name="ScaleType">0</token>
								<bool name="Selectable">true</bool>
								<bool name="Selected">false</bool>
								<Ref name="SelectionImageObject">null</Ref>
								<UDim2 name="Size">
									<XS>0.5</XS>
									<XO>0</XO>
									<YS>0.5</YS>
									<YO>0</YO>
								</UDim2>
								<token name="SizeConstraint">0</token>
								<Rect2D name="SliceCenter">
									<min>
										<X>0</X>
										<Y>0</Y>
									</min>
									<max>
										<X>0</X>
										<Y>0</Y>
									</max>
								</Rect2D>
								<float name="SliceScale">1</float>
								<token name="Style">0</token>
								<BinaryString name="Tags"></BinaryString>
								<UDim2 name="TileSize">
									<XS>1</XS>
									<XO>0</XO>
									<YS>1</YS>
									<YO>0</YO>
								</UDim2>
								<bool name="Visible">true</bool>
								<int name="ZIndex">1</int>
							</Properties>
						</Item>
						<Item class="UIListLayout" referent="RBX25D4B190E1424990A0513B064334215F">
							<Properties>
								<token name="FillDirection">0</token>
								<token name="HorizontalAlignment">0</token>
								<string name="Name">UIListLayout</string>
								<UDim name="Padding">
									<S>0</S>
									<O>0</O>
								</UDim>
								<token name="SortOrder">2</token>
								<BinaryString name="Tags"></BinaryString>
								<token name="VerticalAlignment">0</token>
							</Properties>
						</Item>
					</Item>
					<Item class="Frame" referent="RBX1E2EF6B8F8D7462D9164698A21B2038C">
						<Properties>
							<bool name="Active">false</bool>
							<Vector2 name="AnchorPoint">
								<X>0</X>
								<Y>0</Y>
							</Vector2>
							<bool name="AutoLocalize">true</bool>
							<Color3 name="BackgroundColor3">
								<R>1</R>
								<G>1</G>
								<B>1</B>
							</Color3>
							<float name="BackgroundTransparency">1</float>
							<Color3 name="BorderColor3">
								<R>0.105882362</R>
								<G>0.164705887</G>
								<B>0.207843155</B>
							</Color3>
							<token name="BorderMode">0</token>
							<int name="BorderSizePixel">1</int>
							<bool name="ClipsDescendants">false</bool>
							<bool name="Draggable">false</bool>
							<int name="LayoutOrder">0</int>
							<string name="Name">inventoryContainer</string>
							<Ref name="NextSelectionDown">null</Ref>
							<Ref name="NextSelectionLeft">null</Ref>
							<Ref name="NextSelectionRight">null</Ref>
							<Ref name="NextSelectionUp">null</Ref>
							<UDim2 name="Position">
								<XS>0</XS>
								<XO>0</XO>
								<YS>0</YS>
								<YO>0</YO>
							</UDim2>
							<Ref name="RootLocalizationTable">null</Ref>
							<float name="Rotation">0</float>
							<bool name="Selectable">false</bool>
							<Ref name="SelectionImageObject">null</Ref>
							<UDim2 name="Size">
								<XS>1</XS>
								<XO>0</XO>
								<YS>1</YS>
								<YO>0</YO>
							</UDim2>
							<token name="SizeConstraint">0</token>
							<token name="Style">0</token>
							<BinaryString name="Tags"></BinaryString>
							<bool name="Visible">true</bool>
							<int name="ZIndex">1</int>
						</Properties>
						<Item class="Frame" referent="RBX0A70322DB9BD46229F56202E0316AE62">
							<Properties>
								<bool name="Active">false</bool>
								<Vector2 name="AnchorPoint">
									<X>0</X>
									<Y>0</Y>
								</Vector2>
								<bool name="AutoLocalize">true</bool>
								<Color3 name="BackgroundColor3">
									<R>1</R>
									<G>1</G>
									<B>1</B>
								</Color3>
								<float name="BackgroundTransparency">1</float>
								<Color3 name="BorderColor3">
									<R>0.105882362</R>
									<G>0.164705887</G>
									<B>0.207843155</B>
								</Color3>
								<token name="BorderMode">0</token>
								<int name="BorderSizePixel">1</int>
								<bool name="ClipsDescendants">false</bool>
								<bool name="Draggable">false</bool>
								<int name="LayoutOrder">0</int>
								<string name="Name">inventory</string>
								<Ref name="NextSelectionDown">null</Ref>
								<Ref name="NextSelectionLeft">null</Ref>
								<Ref name="NextSelectionRight">null</Ref>
								<Ref name="NextSelectionUp">null</Ref>
								<UDim2 name="Position">
									<XS>0</XS>
									<XO>0</XO>
									<YS>0</YS>
									<YO>0</YO>
								</UDim2>
								<Ref name="RootLocalizationTable">null</Ref>
								<float name="Rotation">0</float>
								<bool name="Selectable">false</bool>
								<Ref name="SelectionImageObject">null</Ref>
								<UDim2 name="Size">
									<XS>1</XS>
									<XO>0</XO>
									<YS>1</YS>
									<YO>0</YO>
								</UDim2>
								<token name="SizeConstraint">0</token>
								<token name="Style">0</token>
								<BinaryString name="Tags"></BinaryString>
								<bool name="Visible">true</bool>
								<int name="ZIndex">1</int>
							</Properties>
							<Item class="UIAspectRatioConstraint" referent="RBX211C481011554956B2C7240EFF40AD45">
								<Properties>
									<float name="AspectRatio">7.16599989</float>
									<token name="AspectType">0</token>
									<token name="DominantAxis">0</token>
									<string name="Name">UIAspectRatioConstraint</string>
									<BinaryString name="Tags"></BinaryString>
								</Properties>
							</Item>
							<Item class="ImageButton" referent="RBX8032EDF1693D41698D987D1475A7B629">
								<Properties>
									<bool name="Active">true</bool>
									<Vector2 name="AnchorPoint">
										<X>0</X>
										<Y>0</Y>
									</Vector2>
									<bool name="AutoButtonColor">true</bool>
									<bool name="AutoLocalize">true</bool>
									<Color3 name="BackgroundColor3">
										<R>1</R>
										<G>1</G>
										<B>1</B>
									</Color3>
									<float name="BackgroundTransparency">1</float>
									<Color3 name="BorderColor3">
										<R>0.105882362</R>
										<G>0.164705887</G>
										<B>0.207843155</B>
									</Color3>
									<token name="BorderMode">0</token>
									<int name="BorderSizePixel">1</int>
									<bool name="ClipsDescendants">false</bool>
									<bool name="Draggable">false</bool>
									<Content name="HoverImage"><null></null></Content>
									<Content name="Image"><url>rbxassetid://3737305020</url></Content>
									<Color3 name="ImageColor3">
										<R>1</R>
										<G>1</G>
										<B>1</B>
									</Color3>
									<Vector2 name="ImageRectOffset">
										<X>0</X>
										<Y>0</Y>
									</Vector2>
									<Vector2 name="ImageRectSize">
										<X>0</X>
										<Y>0</Y>
									</Vector2>
									<float name="ImageTransparency">0</float>
									<int name="LayoutOrder">0</int>
									<bool name="Modal">false</bool>
									<string name="Name">s1</string>
									<Ref name="NextSelectionDown">null</Ref>
									<Ref name="NextSelectionLeft">null</Ref>
									<Ref name="NextSelectionRight">null</Ref>
									<Ref name="NextSelectionUp">null</Ref>
									<UDim2 name="Position">
										<XS>0.0313703716</XS>
										<XO>0</XO>
										<YS>0.0661468133</YS>
										<YO>0</YO>
									</UDim2>
									<Content name="PressedImage"><null></null></Content>
									<Ref name="RootLocalizationTable">null</Ref>
									<float name="Rotation">0</float>
									<token name="ScaleType">0</token>
									<bool name="Selectable">true</bool>
									<bool name="Selected">false</bool>
									<Ref name="SelectionImageObject">null</Ref>
									<UDim2 name="Size">
										<XS>0.119946808</XS>
										<XO>0</XO>
										<YS>0.859538734</YS>
										<YO>0</YO>
									</UDim2>
									<token name="SizeConstraint">0</token>
									<Rect2D name="SliceCenter">
										<min>
											<X>0</X>
											<Y>0</Y>
										</min>
										<max>
											<X>0</X>
											<Y>0</Y>
										</max>
									</Rect2D>
									<float name="SliceScale">1</float>
									<token name="Style">0</token>
									<BinaryString name="Tags"></BinaryString>
									<UDim2 name="TileSize">
										<XS>1</XS>
										<XO>0</XO>
										<YS>1</YS>
										<YO>0</YO>
									</UDim2>
									<bool name="Visible">true</bool>
									<int name="ZIndex">1</int>
								</Properties>
								<Item class="UIAspectRatioConstraint" referent="RBX3018E9FB932542F399D9FC4877AF9772">
									<Properties>
										<float name="AspectRatio">1</float>
										<token name="AspectType">0</token>
										<token name="DominantAxis">1</token>
										<string name="Name">UIAspectRatioConstraint</string>
										<BinaryString name="Tags"></BinaryString>
									</Properties>
								</Item>
							</Item>
							<Item class="ImageButton" referent="RBX065F545B51334667925CA47BAE2B7CCA">
								<Properties>
									<bool name="Active">true</bool>
									<Vector2 name="AnchorPoint">
										<X>0</X>
										<Y>0</Y>
									</Vector2>
									<bool name="AutoButtonColor">true</bool>
									<bool name="AutoLocalize">true</bool>
									<Color3 name="BackgroundColor3">
										<R>1</R>
										<G>1</G>
										<B>1</B>
									</Color3>
									<float name="BackgroundTransparency">1</float>
									<Color3 name="BorderColor3">
										<R>0.105882362</R>
										<G>0.164705887</G>
										<B>0.207843155</B>
									</Color3>
									<token name="BorderMode">0</token>
									<int name="BorderSizePixel">1</int>
									<bool name="ClipsDescendants">false</bool>
									<bool name="Draggable">false</bool>
									<Content name="HoverImage"><null></null></Content>
									<Content name="Image"><url>rbxassetid://3737305020</url></Content>
									<Color3 name="ImageColor3">
										<R>1</R>
										<G>1</G>
										<B>1</B>
									</Color3>
									<Vector2 name="ImageRectOffset">
										<X>0</X>
										<Y>0</Y>
									</Vector2>
									<Vector2 name="ImageRectSize">
										<X>0</X>
										<Y>0</Y>
									</Vector2>
									<float name="ImageTransparency">0</float>
									<int name="LayoutOrder">0</int>
									<bool name="Modal">false</bool>
									<string name="Name">s2</string>
									<Ref name="NextSelectionDown">null</Ref>
									<Ref name="NextSelectionLeft">null</Ref>
									<Ref name="NextSelectionRight">null</Ref>
									<Ref name="NextSelectionUp">null</Ref>
									<UDim2 name="Position">
										<XS>0.151206955</XS>
										<XO>0</XO>
										<YS>0.0661468133</YS>
										<YO>0</YO>
									</UDim2>
									<Content name="PressedImage"><null></null></Content>
									<Ref name="RootLocalizationTable">null</Ref>
									<float name="Rotation">0</float>
									<token name="ScaleType">0</token>
									<bool name="Selectable">true</bool>
									<bool name="Selected">false</bool>
									<Ref name="SelectionImageObject">null</Ref>
									<UDim2 name="Size">
										<XS>0.119946808</XS>
										<XO>0</XO>
										<YS>0.859538734</YS>
										<YO>0</YO>
									</UDim2>
									<token name="SizeConstraint">0</token>
									<Rect2D name="SliceCenter">
										<min>
											<X>0</X>
											<Y>0</Y>
										</min>
										<max>
											<X>0</X>
											<Y>0</Y>
										</max>
									</Rect2D>
									<float name="SliceScale">1</float>
									<token name="Style">0</token>
									<BinaryString name="Tags"></BinaryString>
									<UDim2 name="TileSize">
										<XS>1</XS>
										<XO>0</XO>
										<YS>1</YS>
										<YO>0</YO>
									</UDim2>
									<bool name="Visible">true</bool>
									<int name="ZIndex">1</int>
								</Properties>
								<Item class="UIAspectRatioConstraint" referent="RBXEA56561752FD4B8A8B41BA9042894CAB">
									<Properties>
										<float name="AspectRatio">1</float>
										<token name="AspectType">0</token>
										<token name="DominantAxis">1</token>
										<string name="Name">UIAspectRatioConstraint</string>
										<BinaryString name="Tags"></BinaryString>
									</Properties>
								</Item>
							</Item>
							<Item class="ImageButton" referent="RBX4D16999B25FF4101B6DC97E23C1AC159">
								<Properties>
									<bool name="Active">true</bool>
									<Vector2 name="AnchorPoint">
										<X>0</X>
										<Y>0</Y>
									</Vector2>
									<bool name="AutoButtonColor">true</bool>
									<bool name="AutoLocalize">true</bool>
									<Color3 name="BackgroundColor3">
										<R>1</R>
										<G>1</G>
										<B>1</B>
									</Color3>
									<float name="BackgroundTransparency">1</float>
									<Color3 name="BorderColor3">
										<R>0.105882362</R>
										<G>0.164705887</G>
										<B>0.207843155</B>
									</Color3>
									<token name="BorderMode">0</token>
									<int name="BorderSizePixel">1</int>
									<bool name="ClipsDescendants">false</bool>
									<bool name="Draggable">false</bool>
									<Content name="HoverImage"><null></null></Content>
									<Content name="Image"><url>rbxassetid://3737305020</url></Content>
									<Color3 name="ImageColor3">
										<R>1</R>
										<G>1</G>
										<B>1</B>
									</Color3>
									<Vector2 name="ImageRectOffset">
										<X>0</X>
										<Y>0</Y>
									</Vector2>
									<Vector2 name="ImageRectSize">
										<X>0</X>
										<Y>0</Y>
									</Vector2>
									<float name="ImageTransparency">0</float>
									<int name="LayoutOrder">0</int>
									<bool name="Modal">false</bool>
									<string name="Name">s3</string>
									<Ref name="NextSelectionDown">null</Ref>
									<Ref name="NextSelectionLeft">null</Ref>
									<Ref name="NextSelectionRight">null</Ref>
									<Ref name="NextSelectionUp">null</Ref>
									<UDim2 name="Position">
										<XS>0.271043539</XS>
										<XO>0</XO>
										<YS>0.0661468133</YS>
										<YO>0</YO>
									</UDim2>
									<Content name="PressedImage"><null></null></Content>
									<Ref name="RootLocalizationTable">null</Ref>
									<float name="Rotation">0</float>
									<token name="ScaleType">0</token>
									<bool name="Selectable">true</bool>
									<bool name="Selected">false</bool>
									<Ref name="SelectionImageObject">null</Ref>
									<UDim2 name="Size">
										<XS>0.119946808</XS>
										<XO>0</XO>
										<YS>0.859538734</YS>
										<YO>0</YO>
									</UDim2>
									<token name="SizeConstraint">0</token>
									<Rect2D name="SliceCenter">
										<min>
											<X>0</X>
											<Y>0</Y>
										</min>
										<max>
											<X>0</X>
											<Y>0</Y>
										</max>
									</Rect2D>
									<float name="SliceScale">1</float>
									<token name="Style">0</token>
									<BinaryString name="Tags"></BinaryString>
									<UDim2 name="TileSize">
										<XS>1</XS>
										<XO>0</XO>
										<YS>1</YS>
										<YO>0</YO>
									</UDim2>
									<bool name="Visible">true</bool>
									<int name="ZIndex">1</int>
								</Properties>
								<Item class="UIAspectRatioConstraint" referent="RBXFF161FF2849849B495E4C73670C67386">
									<Properties>
										<float name="AspectRatio">1</float>
										<token name="AspectType">0</token>
										<token name="DominantAxis">1</token>
										<string name="Name">UIAspectRatioConstraint</string>
										<BinaryString name="Tags"></BinaryString>
									</Properties>
								</Item>
							</Item>
							<Item class="ImageButton" referent="RBX616F0F02128B454FBFAAC2817C9C66A0">
								<Properties>
									<bool name="Active">true</bool>
									<Vector2 name="AnchorPoint">
										<X>0</X>
										<Y>0</Y>
									</Vector2>
									<bool name="AutoButtonColor">true</bool>
									<bool name="AutoLocalize">true</bool>
									<Color3 name="BackgroundColor3">
										<R>1</R>
										<G>1</G>
										<B>1</B>
									</Color3>
									<float name="BackgroundTransparency">1</float>
									<Color3 name="BorderColor3">
										<R>0.105882362</R>
										<G>0.164705887</G>
										<B>0.207843155</B>
									</Color3>
									<token name="BorderMode">0</token>
									<int name="BorderSizePixel">1</int>
									<bool name="ClipsDescendants">false</bool>
									<bool name="Draggable">false</bool>
									<Content name="HoverImage"><null></null></Content>
									<Content name="Image"><url>rbxassetid://3737305020</url></Content>
									<Color3 name="ImageColor3">
										<R>1</R>
										<G>1</G>
										<B>1</B>
									</Color3>
									<Vector2 name="ImageRectOffset">
										<X>0</X>
										<Y>0</Y>
									</Vector2>
									<Vector2 name="ImageRectSize">
										<X>0</X>
										<Y>0</Y>
									</Vector2>
									<float name="ImageTransparency">0</float>
									<int name="LayoutOrder">0</int>
									<bool name="Modal">false</bool>
									<string name="Name">s5</string>
									<Ref name="NextSelectionDown">null</Ref>
									<Ref name="NextSelectionLeft">null</Ref>
									<Ref name="NextSelectionRight">null</Ref>
									<Ref name="NextSelectionUp">null</Ref>
									<UDim2 name="Position">
										<XS>0.606355548</XS>
										<XO>0</XO>
										<YS>0.0661468133</YS>
										<YO>0</YO>
									</UDim2>
									<Content name="PressedImage"><null></null></Content>
									<Ref name="RootLocalizationTable">null</Ref>
									<float name="Rotation">0</float>
									<token name="ScaleType">0</token>
									<bool name="Selectable">true</bool>
									<bool name="Selected">false</bool>
									<Ref name="SelectionImageObject">null</Ref>
									<UDim2 name="Size">
										<XS>0.119946808</XS>
										<XO>0</XO>
										<YS>0.859538734</YS>
										<YO>0</YO>
									</UDim2>
									<token name="SizeConstraint">0</token>
									<Rect2D name="SliceCenter">
										<min>
											<X>0</X>
											<Y>0</Y>
										</min>
										<max>
											<X>0</X>
											<Y>0</Y>
										</max>
									</Rect2D>
									<float name="SliceScale">1</float>
									<token name="Style">0</token>
									<BinaryString name="Tags"></BinaryString>
									<UDim2 name="TileSize">
										<XS>1</XS>
										<XO>0</XO>
										<YS>1</YS>
										<YO>0</YO>
									</UDim2>
									<bool name="Visible">true</bool>
									<int name="ZIndex">1</int>
								</Properties>
								<Item class="UIAspectRatioConstraint" referent="RBX6589873D5DB44EB9A22C36439ED77571">
									<Properties>
										<float name="AspectRatio">1</float>
										<token name="AspectType">0</token>
										<token name="DominantAxis">1</token>
										<string name="Name">UIAspectRatioConstraint</string>
										<BinaryString name="Tags"></BinaryString>
									</Properties>
								</Item>
							</Item>
							<Item class="ImageButton" referent="RBX33496991C9DB482FA281B8F0084AC209">
								<Properties>
									<bool name="Active">true</bool>
									<Vector2 name="AnchorPoint">
										<X>0</X>
										<Y>0</Y>
									</Vector2>
									<bool name="AutoButtonColor">true</bool>
									<bool name="AutoLocalize">true</bool>
									<Color3 name="BackgroundColor3">
										<R>1</R>
										<G>1</G>
										<B>1</B>
									</Color3>
									<float name="BackgroundTransparency">1</float>
									<Color3 name="BorderColor3">
										<R>0.105882362</R>
										<G>0.164705887</G>
										<B>0.207843155</B>
									</Color3>
									<token name="BorderMode">0</token>
									<int name="BorderSizePixel">1</int>
									<bool name="ClipsDescendants">false</bool>
									<bool name="Draggable">false</bool>
									<Content name="HoverImage"><null></null></Content>
									<Content name="Image"><url>rbxassetid://3737305020</url></Content>
									<Color3 name="ImageColor3">
										<R>1</R>
										<G>1</G>
										<B>1</B>
									</Color3>
									<Vector2 name="ImageRectOffset">
										<X>0</X>
										<Y>0</Y>
									</Vector2>
									<Vector2 name="ImageRectSize">
										<X>0</X>
										<Y>0</Y>
									</Vector2>
									<float name="ImageTransparency">0</float>
									<int name="LayoutOrder">0</int>
									<bool name="Modal">false</bool>
									<string name="Name">s4</string>
									<Ref name="NextSelectionDown">null</Ref>
									<Ref name="NextSelectionLeft">null</Ref>
									<Ref name="NextSelectionRight">null</Ref>
									<Ref name="NextSelectionUp">null</Ref>
									<UDim2 name="Position">
										<XS>0.726192117</XS>
										<XO>0</XO>
										<YS>0.0661468133</YS>
										<YO>0</YO>
									</UDim2>
									<Content name="PressedImage"><null></null></Content>
									<Ref name="RootLocalizationTable">null</Ref>
									<float name="Rotation">0</float>
									<token name="ScaleType">0</token>
									<bool name="Selectable">true</bool>
									<bool name="Selected">false</bool>
									<Ref name="SelectionImageObject">null</Ref>
									<UDim2 name="Size">
										<XS>0.119946808</XS>
										<XO>0</XO>
										<YS>0.859538734</YS>
										<YO>0</YO>
									</UDim2>
									<token name="SizeConstraint">0</token>
									<Rect2D name="SliceCenter">
										<min>
											<X>0</X>
											<Y>0</Y>
										</min>
										<max>
											<X>0</X>
											<Y>0</Y>
										</max>
									</Rect2D>
									<float name="SliceScale">1</float>
									<token name="Style">0</token>
									<BinaryString name="Tags"></BinaryString>
									<UDim2 name="TileSize">
										<XS>1</XS>
										<XO>0</XO>
										<YS>1</YS>
										<YO>0</YO>
									</UDim2>
									<bool name="Visible">true</bool>
									<int name="ZIndex">1</int>
								</Properties>
								<Item class="UIAspectRatioConstraint" referent="RBX64D85638A9464915ACABFA12EA10C81C">
									<Properties>
										<float name="AspectRatio">1</float>
										<token name="AspectType">0</token>
										<token name="DominantAxis">1</token>
										<string name="Name">UIAspectRatioConstraint</string>
										<BinaryString name="Tags"></BinaryString>
									</Properties>
								</Item>
							</Item>
							<Item class="ImageButton" referent="RBX262E9B88930A49858777B0CF6B46442E">
								<Properties>
									<bool name="Active">true</bool>
									<Vector2 name="AnchorPoint">
										<X>0</X>
										<Y>0</Y>
									</Vector2>
									<bool name="AutoButtonColor">true</bool>
									<bool name="AutoLocalize">true</bool>
									<Color3 name="BackgroundColor3">
										<R>1</R>
										<G>1</G>
										<B>1</B>
									</Color3>
									<float name="BackgroundTransparency">1</float>
									<Color3 name="BorderColor3">
										<R>0.105882362</R>
										<G>0.164705887</G>
										<B>0.207843155</B>
									</Color3>
									<token name="BorderMode">0</token>
									<int name="BorderSizePixel">1</int>
									<bool name="ClipsDescendants">false</bool>
									<bool name="Draggable">false</bool>
									<Content name="HoverImage"><null></null></Content>
									<Content name="Image"><url>rbxassetid://3737305020</url></Content>
									<Color3 name="ImageColor3">
										<R>1</R>
										<G>1</G>
										<B>1</B>
									</Color3>
									<Vector2 name="ImageRectOffset">
										<X>0</X>
										<Y>0</Y>
									</Vector2>
									<Vector2 name="ImageRectSize">
										<X>0</X>
										<Y>0</Y>
									</Vector2>
									<float name="ImageTransparency">0</float>
									<int name="LayoutOrder">0</int>
									<bool name="Modal">false</bool>
									<string name="Name">s6</string>
									<Ref name="NextSelectionDown">null</Ref>
									<Ref name="NextSelectionLeft">null</Ref>
									<Ref name="NextSelectionRight">null</Ref>
									<Ref name="NextSelectionUp">null</Ref>
									<UDim2 name="Position">
										<XS>0.846028686</XS>
										<XO>0</XO>
										<YS>0.0661468133</YS>
										<YO>0</YO>
									</UDim2>
									<Content name="PressedImage"><null></null></Content>
									<Ref name="RootLocalizationTable">null</Ref>
									<float name="Rotation">0</float>
									<token name="ScaleType">0</token>
									<bool name="Selectable">true</bool>
									<bool name="Selected">false</bool>
									<Ref name="SelectionImageObject">null</Ref>
									<UDim2 name="Size">
										<XS>0.119946808</XS>
										<XO>0</XO>
										<YS>0.859538734</YS>
										<YO>0</YO>
									</UDim2>
									<token name="SizeConstraint">0</token>
									<Rect2D name="SliceCenter">
										<min>
											<X>0</X>
											<Y>0</Y>
										</min>
										<max>
											<X>0</X>
											<Y>0</Y>
										</max>
									</Rect2D>
									<float name="SliceScale">1</float>
									<token name="Style">0</token>
									<BinaryString name="Tags"></BinaryString>
									<UDim2 name="TileSize">
										<XS>1</XS>
										<XO>0</XO>
										<YS>1</YS>
										<YO>0</YO>
									</UDim2>
									<bool name="Visible">true</bool>
									<int name="ZIndex">1</int>
								</Properties>
								<Item class="UIAspectRatioConstraint" referent="RBX6ED645FD56D547B58D5C55BDA5E48ADD">
									<Properties>
										<float name="AspectRatio">1</float>
										<token name="AspectType">0</token>
										<token name="DominantAxis">1</token>
										<string name="Name">UIAspectRatioConstraint</string>
										<BinaryString name="Tags"></BinaryString>
									</Properties>
								</Item>
							</Item>
						</Item>
						<Item class="UIListLayout" referent="RBX785AB1D35E4844759BDE5D5F5042A94E">
							<Properties>
								<token name="FillDirection">0</token>
								<token name="HorizontalAlignment">1</token>
								<string name="Name">UIListLayout</string>
								<UDim name="Padding">
									<S>0</S>
									<O>0</O>
								</UDim>
								<token name="SortOrder">2</token>
								<BinaryString name="Tags"></BinaryString>
								<token name="VerticalAlignment">2</token>
							</Properties>
						</Item>
					</Item>
					<Item class="UIAspectRatioConstraint" referent="RBX4CA6B93AD1C844A2A984CA8C4574C06C">
						<Properties>
							<float name="AspectRatio">2.32399988</float>
							<token name="AspectType">0</token>
							<token name="DominantAxis">0</token>
							<string name="Name">UIAspectRatioConstraint</string>
							<BinaryString name="Tags"></BinaryString>
						</Properties>
					</Item>
				</Item>
				<Item class="ImageLabel" referent="RBXF00488DF395C43EB8C742CA201577133">
					<Properties>
						<bool name="Active">false</bool>
						<Vector2 name="AnchorPoint">
							<X>0</X>
							<Y>0</Y>
						</Vector2>
						<bool name="AutoLocalize">true</bool>
						<Color3 name="BackgroundColor3">
							<R>0.819607913</R>
							<G>0.819607913</G>
							<B>0.819607913</B>
						</Color3>
						<float name="BackgroundTransparency">1</float>
						<Color3 name="BorderColor3">
							<R>0.105882362</R>
							<G>0.164705887</G>
							<B>0.207843155</B>
						</Color3>
						<token name="BorderMode">0</token>
						<int name="BorderSizePixel">1</int>
						<bool name="ClipsDescendants">false</bool>
						<bool name="Draggable">false</bool>
						<Content name="Image"><url>rbxassetid://3737990306</url></Content>
						<Color3 name="ImageColor3">
							<R>0.819607913</R>
							<G>0.819607913</G>
							<B>0.819607913</B>
						</Color3>
						<Vector2 name="ImageRectOffset">
							<X>0</X>
							<Y>0</Y>
						</Vector2>
						<Vector2 name="ImageRectSize">
							<X>0</X>
							<Y>0</Y>
						</Vector2>
						<float name="ImageTransparency">0</float>
						<int name="LayoutOrder">0</int>
						<string name="Name">ImageLabel</string>
						<Ref name="NextSelectionDown">null</Ref>
						<Ref name="NextSelectionLeft">null</Ref>
						<Ref name="NextSelectionRight">null</Ref>
						<Ref name="NextSelectionUp">null</Ref>
						<UDim2 name="Position">
							<XS>0.6779387</XS>
							<XO>0</XO>
							<YS>-0.951956391</YS>
							<YO>0</YO>
						</UDim2>
						<Ref name="RootLocalizationTable">null</Ref>
						<float name="Rotation">0</float>
						<token name="ScaleType">0</token>
						<bool name="Selectable">false</bool>
						<Ref name="SelectionImageObject">null</Ref>
						<UDim2 name="Size">
							<XS>0</XS>
							<XO>984</XO>
							<YS>0</YS>
							<YO>587</YO>
						</UDim2>
						<token name="SizeConstraint">0</token>
						<Rect2D name="SliceCenter">
							<min>
								<X>0</X>
								<Y>0</Y>
							</min>
							<max>
								<X>0</X>
								<Y>0</Y>
							</max>
						</Rect2D>
						<float name="SliceScale">1</float>
						<BinaryString name="Tags"></BinaryString>
						<UDim2 name="TileSize">
							<XS>1</XS>
							<XO>0</XO>
							<YS>1</YS>
							<YO>0</YO>
						</UDim2>
						<bool name="Visible">true</bool>
						<int name="ZIndex">1</int>
					</Properties>
					<Item class="ImageLabel" referent="RBXE1C29E926D934BC09B10564A42548B36">
						<Properties>
							<bool name="Active">false</bool>
							<Vector2 name="AnchorPoint">
								<X>0</X>
								<Y>0</Y>
							</Vector2>
							<bool name="AutoLocalize">true</bool>
							<Color3 name="BackgroundColor3">
								<R>0.819607913</R>
								<G>0.819607913</G>
								<B>0.819607913</B>
							</Color3>
							<float name="BackgroundTransparency">1</float>
							<Color3 name="BorderColor3">
								<R>0.105882362</R>
								<G>0.164705887</G>
								<B>0.207843155</B>
							</Color3>
							<token name="BorderMode">0</token>
							<int name="BorderSizePixel">1</int>
							<bool name="ClipsDescendants">false</bool>
							<bool name="Draggable">false</bool>
							<Content name="Image"><url>rbxassetid://3737981859</url></Content>
							<Color3 name="ImageColor3">
								<R>0.945098102</R>
								<G>0.945098102</G>
								<B>0.945098102</B>
							</Color3>
							<Vector2 name="ImageRectOffset">
								<X>0</X>
								<Y>0</Y>
							</Vector2>
							<Vector2 name="ImageRectSize">
								<X>0</X>
								<Y>0</Y>
							</Vector2>
							<float name="ImageTransparency">0</float>
							<int name="LayoutOrder">0</int>
							<string name="Name">ImageLabel</string>
							<Ref name="NextSelectionDown">null</Ref>
							<Ref name="NextSelectionLeft">null</Ref>
							<Ref name="NextSelectionRight">null</Ref>
							<Ref name="NextSelectionUp">null</Ref>
							<UDim2 name="Position">
								<XS>0.0101626012</XS>
								<XO>0</XO>
								<YS>0.020442931</YS>
								<YO>0</YO>
							</UDim2>
							<Ref name="RootLocalizationTable">null</Ref>
							<float name="Rotation">0</float>
							<token name="ScaleType">0</token>
							<bool name="Selectable">false</bool>
							<Ref name="SelectionImageObject">null</Ref>
							<UDim2 name="Size">
								<XS>0.981707335</XS>
								<XO>0</XO>
								<YS>0.959114134</YS>
								<YO>0</YO>
							</UDim2>
							<token name="SizeConstraint">0</token>
							<Rect2D name="SliceCenter">
								<min>
									<X>0</X>
									<Y>0</Y>
								</min>
								<max>
									<X>0</X>
									<Y>0</Y>
								</max>
							</Rect2D>
							<float name="SliceScale">1</float>
							<BinaryString name="Tags"></BinaryString>
							<UDim2 name="TileSize">
								<XS>1</XS>
								<XO>0</XO>
								<YS>1</YS>
								<YO>0</YO>
							</UDim2>
							<bool name="Visible">true</bool>
							<int name="ZIndex">1</int>
						</Properties>
					</Item>
					<Item class="TextBox" referent="RBXDED5C1AABA404D87A4CAB2052272C943">
						<Properties>
							<bool name="Active">true</bool>
							<Vector2 name="AnchorPoint">
								<X>0</X>
								<Y>0</Y>
							</Vector2>
							<bool name="AutoLocalize">true</bool>
							<Color3 name="BackgroundColor3">
								<R>0</R>
								<G>0</G>
								<B>0</B>
							</Color3>
							<float name="BackgroundTransparency">1</float>
							<Color3 name="BorderColor3">
								<R>0.105882362</R>
								<G>0.164705887</G>
								<B>0.207843155</B>
							</Color3>
							<token name="BorderMode">0</token>
							<int name="BorderSizePixel">0</int>
							<bool name="ClearTextOnFocus">true</bool>
							<bool name="ClipsDescendants">false</bool>
							<bool name="Draggable">false</bool>
							<token name="Font">3</token>
							<int name="LayoutOrder">0</int>
							<float name="LineHeight">1</float>
							<bool name="MultiLine">false</bool>
							<string name="Name">TextBox</string>
							<Ref name="NextSelectionDown">null</Ref>
							<Ref name="NextSelectionLeft">null</Ref>
							<Ref name="NextSelectionRight">null</Ref>
							<Ref name="NextSelectionUp">null</Ref>
							<Color3 name="PlaceholderColor3">
								<R>0.699999988</R>
								<G>0.699999988</G>
								<B>0.699999988</B>
							</Color3>
							<string name="PlaceholderText"></string>
							<UDim2 name="Position">
								<XS>0.275000006</XS>
								<XO>0</XO>
								<YS>0.0500000007</YS>
								<YO>0</YO>
							</UDim2>
							<Ref name="RootLocalizationTable">null</Ref>
							<float name="Rotation">0</float>
							<bool name="Selectable">true</bool>
							<Ref name="SelectionImageObject">null</Ref>
							<bool name="ShowNativeInput">true</bool>
							<UDim2 name="Size">
								<XS>0.449999988</XS>
								<XO>0</XO>
								<YS>0.119000003</YS>
								<YO>0</YO>
							</UDim2>
							<token name="SizeConstraint">0</token>
							<BinaryString name="Tags"></BinaryString>
							<string name="Text"></string>
							<Color3 name="TextColor3">
								<R>0</R>
								<G>0</G>
								<B>0</B>
							</Color3>
							<bool name="TextEditable">true</bool>
							<bool name="TextScaled">false</bool>
							<float name="TextSize">14</float>
							<Color3 name="TextStrokeColor3">
								<R>0</R>
								<G>0</G>
								<B>0</B>
							</Color3>
							<float name="TextStrokeTransparency">1</float>
							<float name="TextTransparency">0</float>
							<token name="TextTruncate">0</token>
							<bool name="TextWrapped">false</bool>
							<token name="TextXAlignment">2</token>
							<token name="TextYAlignment">1</token>
							<bool name="Visible">true</bool>
							<int name="ZIndex">1</int>
						</Properties>
						<Item class="ImageLabel" referent="RBXB9620C22D71B490C8C14DD0794B02039">
							<Properties>
								<bool name="Active">false</bool>
								<Vector2 name="AnchorPoint">
									<X>0</X>
									<Y>0</Y>
								</Vector2>
								<bool name="AutoLocalize">true</bool>
								<Color3 name="BackgroundColor3">
									<R>1</R>
									<G>1</G>
									<B>1</B>
								</Color3>
								<float name="BackgroundTransparency">1</float>
								<Color3 name="BorderColor3">
									<R>0.105882362</R>
									<G>0.164705887</G>
									<B>0.207843155</B>
								</Color3>
								<token name="BorderMode">0</token>
								<int name="BorderSizePixel">1</int>
								<bool name="ClipsDescendants">false</bool>
								<bool name="Draggable">false</bool>
								<Content name="Image"><url>rbxassetid://3737998185</url></Content>
								<Color3 name="ImageColor3">
									<R>1</R>
									<G>1</G>
									<B>1</B>
								</Color3>
								<Vector2 name="ImageRectOffset">
									<X>0</X>
									<Y>0</Y>
								</Vector2>
								<Vector2 name="ImageRectSize">
									<X>0</X>
									<Y>0</Y>
								</Vector2>
								<float name="ImageTransparency">0</float>
								<int name="LayoutOrder">0</int>
								<string name="Name">ImageLabel</string>
								<Ref name="NextSelectionDown">null</Ref>
								<Ref name="NextSelectionLeft">null</Ref>
								<Ref name="NextSelectionRight">null</Ref>
								<Ref name="NextSelectionUp">null</Ref>
								<UDim2 name="Position">
									<XS>1.32253845e-07</XS>
									<XO>0</XO>
									<YS>-0.0132714389</YS>
									<YO>0</YO>
								</UDim2>
								<Ref name="RootLocalizationTable">null</Ref>
								<float name="Rotation">0</float>
								<token name="ScaleType">0</token>
								<bool name="Selectable">false</bool>
								<Ref name="SelectionImageObject">null</Ref>
								<UDim2 name="Size">
									<XS>1</XS>
									<XO>0</XO>
									<YS>1</YS>
									<YO>0</YO>
								</UDim2>
								<token name="SizeConstraint">0</token>
								<Rect2D name="SliceCenter">
									<min>
										<X>0</X>
										<Y>0</Y>
									</min>
									<max>
										<X>0</X>
										<Y>0</Y>
									</max>
								</Rect2D>
								<float name="SliceScale">1</float>
								<BinaryString name="Tags"></BinaryString>
								<UDim2 name="TileSize">
									<XS>1</XS>
									<XO>0</XO>
									<YS>1</YS>
									<YO>0</YO>
								</UDim2>
								<bool name="Visible">true</bool>
								<int name="ZIndex">1</int>
							</Properties>
						</Item>
						<Item class="UIAspectRatioConstraint" referent="RBX97BC0E39309946518AE2B1D4E5937F8B">
							<Properties>
								<float name="AspectRatio">6.5</float>
								<token name="AspectType">0</token>
								<token name="DominantAxis">0</token>
								<string name="Name">UIAspectRatioConstraint</string>
								<BinaryString name="Tags"></BinaryString>
							</Properties>
						</Item>
						<Item class="ImageButton" referent="RBX8E624BAF06104AF48C7D774EBD7909FF">
							<Properties>
								<bool name="Active">true</bool>
								<Vector2 name="AnchorPoint">
									<X>0</X>
									<Y>0</Y>
								</Vector2>
								<bool name="AutoButtonColor">true</bool>
								<bool name="AutoLocalize">true</bool>
								<Color3 name="BackgroundColor3">
									<R>1</R>
									<G>1</G>
									<B>1</B>
								</Color3>
								<float name="BackgroundTransparency">1</float>
								<Color3 name="BorderColor3">
									<R>0.105882362</R>
									<G>0.164705887</G>
									<B>0.207843155</B>
								</Color3>
								<token name="BorderMode">0</token>
								<int name="BorderSizePixel">1</int>
								<bool name="ClipsDescendants">false</bool>
								<bool name="Draggable">false</bool>
								<Content name="HoverImage"><null></null></Content>
								<Content name="Image"><url>rbxassetid://3737997474</url></Content>
								<Color3 name="ImageColor3">
									<R>0.0784313753</R>
									<G>0.0784313753</G>
									<B>0.0784313753</B>
								</Color3>
								<Vector2 name="ImageRectOffset">
									<X>0</X>
									<Y>0</Y>
								</Vector2>
								<Vector2 name="ImageRectSize">
									<X>0</X>
									<Y>0</Y>
								</Vector2>
								<float name="ImageTransparency">0</float>
								<int name="LayoutOrder">0</int>
								<bool name="Modal">false</bool>
								<string name="Name">ImageButton</string>
								<Ref name="NextSelectionDown">null</Ref>
								<Ref name="NextSelectionLeft">null</Ref>
								<Ref name="NextSelectionRight">null</Ref>
								<Ref name="NextSelectionUp">null</Ref>
								<UDim2 name="Position">
									<XS>0.855904639</XS>
									<XO>0</XO>
									<YS>0.197183222</YS>
									<YO>0</YO>
								</UDim2>
								<Content name="PressedImage"><null></null></Content>
								<Ref name="RootLocalizationTable">null</Ref>
								<float name="Rotation">0</float>
								<token name="ScaleType">0</token>
								<bool name="Selectable">true</bool>
								<bool name="Selected">false</bool>
								<Ref name="SelectionImageObject">null</Ref>
								<UDim2 name="Size">
									<XS>0.0888407305</XS>
									<XO>0</XO>
									<YS>0.577464759</YS>
									<YO>0</YO>
								</UDim2>
								<token name="SizeConstraint">0</token>
								<Rect2D name="SliceCenter">
									<min>
										<X>0</X>
										<Y>0</Y>
									</min>
									<max>
										<X>0</X>
										<Y>0</Y>
									</max>
								</Rect2D>
								<float name="SliceScale">1</float>
								<token name="Style">0</token>
								<BinaryString name="Tags"></BinaryString>
								<UDim2 name="TileSize">
									<XS>1</XS>
									<XO>0</XO>
									<YS>1</YS>
									<YO>0</YO>
								</UDim2>
								<bool name="Visible">true</bool>
								<int name="ZIndex">1</int>
							</Properties>
							<Item class="UIAspectRatioConstraint" referent="RBX1A283797FFD04A50B43E974552BD7679">
								<Properties>
									<float name="AspectRatio">1</float>
									<token name="AspectType">0</token>
									<token name="DominantAxis">1</token>
									<string name="Name">UIAspectRatioConstraint</string>
									<BinaryString name="Tags"></BinaryString>
								</Properties>
							</Item>
						</Item>
					</Item>
				</Item>
			</Item>
		</Item>
	</Item>
	<Item class="LocalizationService" referent="RBX165311ECEA0E4ECCAEE15CB83676A65F">
		<Properties>
			<string name="Name">LocalizationService</string>
			<BinaryString name="Tags"></BinaryString>
		</Properties>
	</Item>
	<Item class="TeleportService" referent="RBXCB787E482D444AA79D868FAAE84AEF86">
		<Properties>
			<string name="Name">Teleport Service</string>
			<BinaryString name="Tags"></BinaryString>
		</Properties>
	</Item>
	<Item class="CollectionService" referent="RBX5D911EF4A60D4C35A6FA0DA1EBAECB53">
		<Properties>
			<string name="Name">CollectionService</string>
			<BinaryString name="Tags"></BinaryString>
		</Properties>
	</Item>
	<Item class="PhysicsService" referent="RBXC32DA7650BA9440FBF6C5A431F3EAC53">
		<Properties>
			<string name="Name">PhysicsService</string>
			<BinaryString name="Tags"></BinaryString>
		</Properties>
	</Item>
	<Item class="Geometry" referent="RBXD1857BCD71F948AE82A825400E374601">
		<Properties>
			<string name="Name">Geometry</string>
			<BinaryString name="Tags"></BinaryString>
		</Properties>
	</Item>
	<Item class="InsertService" referent="RBX469A78B77F5C451FA76642B1779702A8">
		<Properties>
			<bool name="AllowClientInsertModels">false</bool>
			<bool name="AllowInsertFreeModels">false</bool>
			<string name="Name">InsertService</string>
			<BinaryString name="Tags"></BinaryString>
		</Properties>
	</Item>
	<Item class="GamePassService" referent="RBX59F7AED5C204402BBD384D162572C6B5">
		<Properties>
			<string name="Name">GamePassService</string>
			<BinaryString name="Tags"></BinaryString>
		</Properties>
	</Item>
	<Item class="Debris" referent="RBXB9AC59E49FF14CFB820A98FC03514CC0">
		<Properties>
			<int name="MaxItems">1000</int>
			<string name="Name">Debris</string>
			<BinaryString name="Tags"></BinaryString>
		</Properties>
	</Item>
	<Item class="CookiesService" referent="RBX8704DC3198F74B0B8010DE96E3B288E4">
		<Properties>
			<string name="Name">CookiesService</string>
			<BinaryString name="Tags"></BinaryString>
		</Properties>
	</Item>
	<Item class="VRService" referent="RBX80198B24DD7D45E2A8B15E467B679D5B">
		<Properties>
			<string name="Name">VRService</string>
			<BinaryString name="Tags"></BinaryString>
		</Properties>
	</Item>
	<Item class="ContextActionService" referent="RBX6DE988B0052F4947A88AB0047CBC1519">
		<Properties>
			<string name="Name">ContextActionService</string>
			<BinaryString name="Tags"></BinaryString>
		</Properties>
	</Item>
	<Item class="ScriptService" referent="RBX39372F6F951C408B82A3DF2A3607063E">
		<Properties>
			<string name="Name">Instance</string>
			<BinaryString name="Tags"></BinaryString>
		</Properties>
	</Item>
	<Item class="AssetService" referent="RBX70A70FFD37FC4AB9BE474BFC334000A7">
		<Properties>
			<string name="Name">AssetService</string>
			<BinaryString name="Tags"></BinaryString>
		</Properties>
	</Item>
	<Item class="TouchInputService" referent="RBXF2ECB34C43164A4395CDA6EACEAD9689">
		<Properties>
			<string name="Name">TouchInputService</string>
			<BinaryString name="Tags"></BinaryString>
		</Properties>
	</Item>
	<Item class="Selection" referent="RBX30CDCEB95FB0459DB6DA0B9EC111A0FA">
		<Properties>
			<string name="Name">Selection</string>
			<BinaryString name="Tags"></BinaryString>
		</Properties>
	</Item>
	<Item class="ServerScriptService" referent="6">
		<Properties>
			<bool name="LoadStringEnabled">false</bool>
			<string name="Name">ServerScriptService</string>
			<BinaryString name="Tags"></BinaryString>
		</Properties>
		<Item class="Folder" referent="7">
			<Properties>
				<string name="Name">TS</string>
				<BinaryString name="Tags"></BinaryString>
			</Properties>
			<Item class="Script" referent="8">
				<Properties>
					<bool name="Disabled">false</bool>
					<Content name="LinkedSource"><null></null></Content>
					<string name="Name">main</string>
					<string name="ScriptGuid">{2CAB421C-BF34-4CE2-9F3A-3CE008D8500D}</string>
					<ProtectedString name="Source"><![CDATA[-- Compiled with https://roblox-ts.github.io v0.2.14
-- August 26, 2019, 6:16 PM British Summer Time

local TS = require(game:GetService("ReplicatedStorage"):WaitForChild("rbxts_include"):WaitForChild("RuntimeLib"));
local Players = TS.import(TS.getModule("services")).Players;
local PlayerPlayerManager = TS.import(game:GetService("ServerScriptService"), "TS", "modules", "player", "module").default;
Players.PlayerAdded:Connect(function(player)
	local plr;
	plr = PlayerPlayerManager.new(player, TS.async(function()
		plr:getVehicles();
		wait(5);
		local char = plr:character();
		local res1 = TS.await(char.damage(50));
		wait(5);
	end));
end);
print("Roger that");
]]></ProtectedString>
					<BinaryString name="Tags"></BinaryString>
				</Properties>
			</Item>
			<Item class="Folder" referent="RBX21B2382AFA4C49738FD286832E0C2511">
				<Properties>
					<string name="Name">communicationBroker</string>
					<BinaryString name="Tags"></BinaryString>
				</Properties>
				<Item class="ModuleScript" referent="RBX1A96F0D8BAD7435996DA6C570C48FC66">
					<Properties>
						<Content name="LinkedSource"><null></null></Content>
						<string name="Name">module</string>
						<string name="ScriptGuid">{C49F7BAD-FCBF-4305-8B7C-1B828FF173B1}</string>
						<ProtectedString name="Source"><![CDATA[-- Compiled with https://roblox-ts.github.io v0.2.14
-- August 26, 2019, 6:16 PM British Summer Time

local exports = {};
local remote = Instance.new("RemoteFunction", game.Workspace);
local function yeet()
	print(remote);
end;
exports.yeet = yeet;
return exports;
]]></ProtectedString>
						<BinaryString name="Tags"></BinaryString>
					</Properties>
				</Item>
			</Item>
			<Item class="Folder" referent="RBXDE24DA70ED694884A7651F197FA063E3">
				<Properties>
					<string name="Name">data</string>
					<BinaryString name="Tags"></BinaryString>
				</Properties>
				<Item class="Folder" referent="RBX6BECC6C5D3394CC7A43F2A56357CED7F">
					<Properties>
						<string name="Name">enums</string>
						<BinaryString name="Tags"></BinaryString>
					</Properties>
					<Item class="ModuleScript" referent="RBX0A0AD2F3D6DB43AB9A60B2A7F4AE1290">
						<Properties>
							<Content name="LinkedSource"><null></null></Content>
							<string name="Name">init.module</string>
							<string name="ScriptGuid">{9FDDFC10-5FFA-4CE6-8371-9E9FBDA39686}</string>
							<ProtectedString name="Source"><![CDATA[-- Compiled with https://roblox-ts.github.io v0.2.14
-- August 26, 2019, 6:16 PM British Summer Time

local TS = require(game:GetService("ReplicatedStorage"):WaitForChild("rbxts_include"):WaitForChild("RuntimeLib"));
local exports = {};
local vehicle = TS.import(game:GetService("ServerScriptService"), "TS", "data", "enums", "vehicle");
exports.default = {
	vehicle = vehicle;
};
return exports;
]]></ProtectedString>
							<BinaryString name="Tags"></BinaryString>
						</Properties>
					</Item>
					<Item class="Folder" referent="RBX96F1CDD5C1134201B4C36076581D3B03">
						<Properties>
							<string name="Name">metrosAPI</string>
							<BinaryString name="Tags"></BinaryString>
						</Properties>
						<Item class="ModuleScript" referent="RBXAE215D8F224141D5993F6B4C46DF0A9B">
							<Properties>
								<Content name="LinkedSource"><null></null></Content>
								<string name="Name">module</string>
								<string name="ScriptGuid">{BFE1E6E3-4F94-46B3-9EA6-7DA7335D1BD4}</string>
								<ProtectedString name="Source"><![CDATA[-- Compiled with https://roblox-ts.github.io v0.2.14
-- August 26, 2019, 6:16 PM British Summer Time

local exports = {};
FetchPlayerEnum = FetchPlayerEnum or {};
do
	FetchPlayerEnum.FAILED_TO_FETCH = 0;
	FetchPlayerEnum[0] = "FAILED_TO_FETCH";
	FetchPlayerEnum.FAILED_TO_DECODE = 1;
	FetchPlayerEnum[1] = "FAILED_TO_DECODE";
end;
exports.FetchPlayerEnum = FetchPlayerEnum;
return exports;
]]></ProtectedString>
								<BinaryString name="Tags"></BinaryString>
							</Properties>
						</Item>
					</Item>
					<Item class="Folder" referent="RBX6E0FB755E3C34E80A0BA41C6A44C6595">
						<Properties>
							<string name="Name">player</string>
							<BinaryString name="Tags"></BinaryString>
						</Properties>
						<Item class="ModuleScript" referent="RBX9BA1EDDB74F9407C9A3C342513A12ADB">
							<Properties>
								<Content name="LinkedSource"><null></null></Content>
								<string name="Name">module</string>
								<string name="ScriptGuid">{ECF55857-CC23-4DF2-B04B-F80FE10E30DE}</string>
								<ProtectedString name="Source"><![CDATA[-- Compiled with https://roblox-ts.github.io v0.2.14
-- August 26, 2019, 6:16 PM British Summer Time

local exports = {};
character = character or {};
do
	character.CHARACTER_DOES_NOT_EXIST = 0;
	character[0] = "CHARACTER_DOES_NOT_EXIST";
	character.HUMANOID_DOES_NOT_EXIST = 1;
	character[1] = "HUMANOID_DOES_NOT_EXIST";
	character.PRIMARY_PART_DOES_NOT_EXIST = 2;
	character[2] = "PRIMARY_PART_DOES_NOT_EXIST";
	character.TELEPORT_RESULT_UNKNOWN = 3;
	character[3] = "TELEPORT_RESULT_UNKNOWN";
	character.FAILED_TO_SET_HEALTH = 4;
	character[4] = "FAILED_TO_SET_HEALTH";
end;
exports.character = character;
return exports;
]]></ProtectedString>
								<BinaryString name="Tags"></BinaryString>
							</Properties>
						</Item>
					</Item>
					<Item class="ModuleScript" referent="RBX4DAD3D53698B46CC816960AB24CBC0DF">
						<Properties>
							<Content name="LinkedSource"><null></null></Content>
							<string name="Name">vehicle.module</string>
							<string name="ScriptGuid">{EF985F60-F5B3-4E4C-8758-08DEA63C4A85}</string>
							<ProtectedString name="Source"><![CDATA[-- Compiled with https://roblox-ts.github.io v0.2.14
-- August 26, 2019, 6:16 PM British Summer Time

local exports = {};
vehicleAuthorisationEnum = vehicleAuthorisationEnum or {};
do
	vehicleAuthorisationEnum.ALL = 0;
	vehicleAuthorisationEnum[0] = "ALL";
	vehicleAuthorisationEnum.DRIVE = 1;
	vehicleAuthorisationEnum[1] = "DRIVE";
	vehicleAuthorisationEnum.LOCK = 2;
	vehicleAuthorisationEnum[2] = "LOCK";
	vehicleAuthorisationEnum.NONE = 3;
	vehicleAuthorisationEnum[3] = "NONE";
end;
vehicleErrorEnum = vehicleErrorEnum or {};
do
	vehicleErrorEnum.AUTHENTICATION_FAILED = 0;
	vehicleErrorEnum[0] = "AUTHENTICATION_FAILED";
	vehicleErrorEnum.VEHICLE_UNAVAILABLE = 1;
	vehicleErrorEnum[1] = "VEHICLE_UNAVAILABLE";
	vehicleErrorEnum.VEHICLE_DOES_NOT_EXIST = 2;
	vehicleErrorEnum[2] = "VEHICLE_DOES_NOT_EXIST";
	vehicleErrorEnum.VEHICLE_IN_USE = 3;
	vehicleErrorEnum[3] = "VEHICLE_IN_USE";
	vehicleErrorEnum.VEHICLE_UNKNOWN = 4;
	vehicleErrorEnum[4] = "VEHICLE_UNKNOWN";
	vehicleErrorEnum.VEHICLE_OUT_OF_FUEL = 5;
	vehicleErrorEnum[5] = "VEHICLE_OUT_OF_FUEL";
end;
exports.vehicleAuthorisationEnum = vehicleAuthorisationEnum;
exports.vehicleErrorEnum = vehicleErrorEnum;
return exports;
]]></ProtectedString>
							<BinaryString name="Tags"></BinaryString>
						</Properties>
					</Item>
				</Item>
				<Item class="Folder" referent="RBX62E195968E0948B5A765944ACED02FC2">
					<Properties>
						<string name="Name">metrosAPI</string>
						<BinaryString name="Tags"></BinaryString>
					</Properties>
					<Item class="Folder" referent="RBX01D9DC5C584248368FFDC7568AC5CC9B">
						<Properties>
							<string name="Name">fetchPlayer</string>
							<BinaryString name="Tags"></BinaryString>
						</Properties>
						<Item class="ModuleScript" referent="RBXC9A4D28D69D04D8CA32D077841B71C35">
							<Properties>
								<Content name="LinkedSource"><null></null></Content>
								<string name="Name">module</string>
								<string name="ScriptGuid">{FEAFC62D-91F9-46FB-8F20-660AEE2CF6CE}</string>
								<ProtectedString name="Source"><![CDATA[-- Compiled with https://roblox-ts.github.io v0.2.14
-- August 26, 2019, 6:16 PM British Summer Time

local TS = require(game:GetService("ReplicatedStorage"):WaitForChild("rbxts_include"):WaitForChild("RuntimeLib"));
local exports = {};
local HttpService = TS.import(TS.getModule("services")).HttpService;
local http = TS.import(game:GetService("ServerScriptService"), "TS", "modules", "http", "module").default;
local everything = TS.import(game:GetService("ServerScriptService"), "TS", "data", "metrosAPI", "graphData", "player", "module").default;
local FetchPlayerEnum = TS.import(game:GetService("ServerScriptService"), "TS", "data", "enums", "metrosAPI", "module").FetchPlayerEnum;
exports.default = function(player)
	return TS.Promise.new(function(resolve, reject)
		http:request({
			Url = "http://localhost:4000/graphql";
			Method = "POST";
			Body = HttpService:JSONEncode({
				query = everything(player.UserId, "userId");
			});
			Headers = {
				['Content-Type'] = 'application/json';
			};
		}, {}):andThen(function(result)
			if result.StatusCode == 200 then
				local _0, _1 = pcall(function()
					local idk = HttpService:JSONDecode(result.Body);
					local root = idk;
					local getPlayer = root.data.getPlayer;
					local playerUnknown = getPlayer;
					local player = playerUnknown;
					resolve(player);
				end);
				if not _0 then
					local JsonDecodeException = _1;
					reject(FetchPlayerEnum.FAILED_TO_DECODE);
				end;
			else
				reject(FetchPlayerEnum.FAILED_TO_FETCH);
			end;
		end):catch(function(err)
			reject(FetchPlayerEnum.FAILED_TO_FETCH);
		end);
	end);
end;
return exports;
]]></ProtectedString>
								<BinaryString name="Tags"></BinaryString>
							</Properties>
						</Item>
						<Item class="ModuleScript" referent="RBX718B7931BDF44EEFA9E06558F0AA735E">
							<Properties>
								<Content name="LinkedSource"><null></null></Content>
								<string name="Name">test.module</string>
								<string name="ScriptGuid">{76B4AFA8-D450-48DD-8A67-0E3C4D9FD6F8}</string>
								<ProtectedString name="Source"><![CDATA[-- Compiled with https://roblox-ts.github.io v0.2.14
-- August 26, 2019, 6:16 PM British Summer Time

return nil;
]]></ProtectedString>
								<BinaryString name="Tags"></BinaryString>
							</Properties>
						</Item>
					</Item>
					<Item class="Folder" referent="RBXFA41C6D1B1064E5F8B24E1134BC16754">
						<Properties>
							<string name="Name">graphData</string>
							<BinaryString name="Tags"></BinaryString>
						</Properties>
						<Item class="Folder" referent="RBX39AC560715BF45CE89E850D447D1220F">
							<Properties>
								<string name="Name">player</string>
								<BinaryString name="Tags"></BinaryString>
							</Properties>
							<Item class="ModuleScript" referent="RBX10ADEBABD6B14639863C7D38CF0BD26B">
								<Properties>
									<Content name="LinkedSource"><null></null></Content>
									<string name="Name">module</string>
									<string name="ScriptGuid">{F41EE88F-301F-4111-B591-AA9C46073725}</string>
									<ProtectedString name="Source"><![CDATA[-- Compiled with https://roblox-ts.github.io v0.2.14
-- August 26, 2019, 6:16 PM British Summer Time

local exports = {};
exports.default = function(id, idType)
	return "\
{\
getPlayer(id: \"" .. tostring(id) .. "\", type: \"" .. tostring(idType) .. "\") {\
    userid\
    banned\
    admin\
    banks {\
      id\
      owner_id\
      balance\
      frozen,\
      bank_players {\
        user_id\
        read\
        write\
      }\
    }\
    criminal_offences{\
      id,\
      offense_code\
      retribution_code\
      issued_player\
    }\
    vehicles {\
      id\
      miles\
      vin\
      fuel\
      fuel_capacity\
      fuel_level\
      modifications\
      registration_id\
      created_at\
      deleted_at\
      updated_at\
      registrations {\
        id\
      }\
    }\
  }}";
end;
return exports;
]]></ProtectedString>
									<BinaryString name="Tags"></BinaryString>
								</Properties>
							</Item>
						</Item>
					</Item>
				</Item>
				<Item class="Folder" referent="RBXF6B0CE0436C24D46983F8B45DD6FC981">
					<Properties>
						<string name="Name">stores</string>
						<BinaryString name="Tags"></BinaryString>
					</Properties>
					<Item class="Folder" referent="RBX5054B64E1CAA4BD89344A993CAD20965">
						<Properties>
							<string name="Name">userData</string>
							<BinaryString name="Tags"></BinaryString>
						</Properties>
						<Item class="ModuleScript" referent="RBX26E157018C564F44A23040993FEC5486">
							<Properties>
								<Content name="LinkedSource"><null></null></Content>
								<string name="Name">module</string>
								<string name="ScriptGuid">{DE577553-2A33-4EA4-AA3E-D0D8A269ED16}</string>
								<ProtectedString name="Source"><![CDATA[-- Compiled with https://roblox-ts.github.io v0.2.14
-- August 26, 2019, 6:16 PM British Summer Time

local exports = {};
local UserStore;
do
	UserStore = setmetatable({}, {
		__tostring = function() return "UserStore" end;
	});
	UserStore.__index = UserStore;
	function UserStore.new(...)
		local self = setmetatable({}, UserStore);
		self:constructor(...);
		return self;
	end;
	function UserStore:constructor(...)
		self.playerData = {};
	end;
	function UserStore:getPlayer(userId)
		return self.playerData[userId];
	end;
	function UserStore:addPlayer(userId, player)
		local _0 = self.playerData;
		_0[userId] = player;
		return self:getPlayer(userId);
	end;
	function UserStore:removePlayer(userId)
		self.playerData[userId] = nil;
		return self:getPlayer(userId);
	end;
end;
exports.default = UserStore.new();
return exports;
]]></ProtectedString>
								<BinaryString name="Tags"></BinaryString>
							</Properties>
						</Item>
					</Item>
				</Item>
				<Item class="Folder" referent="RBX4236E9B0667048128684FD9AF37E50B0">
					<Properties>
						<string name="Name">types</string>
						<BinaryString name="Tags"></BinaryString>
					</Properties>
					<Item class="Folder" referent="RBXB9D03C9318F6408D9F6BE87402A168B3">
						<Properties>
							<string name="Name">graph</string>
							<BinaryString name="Tags"></BinaryString>
						</Properties>
						<Item class="ModuleScript" referent="RBX1C96916D2E594BAE9147EE7453C26BF8">
							<Properties>
								<Content name="LinkedSource"><null></null></Content>
								<string name="Name">module</string>
								<string name="ScriptGuid">{046999E2-2401-4158-BB29-B71593821A5A}</string>
								<ProtectedString name="Source"><![CDATA[-- Compiled with https://roblox-ts.github.io v0.2.14
-- August 26, 2019, 6:16 PM British Summer Time

return nil;
]]></ProtectedString>
								<BinaryString name="Tags"></BinaryString>
							</Properties>
						</Item>
					</Item>
					<Item class="ModuleScript" referent="RBX8F9A7A9DD2AF424E95B0D0872433F196">
						<Properties>
							<Content name="LinkedSource"><null></null></Content>
							<string name="Name">http.module</string>
							<string name="ScriptGuid">{9B975774-1D77-4B55-8A44-D235B4217D30}</string>
							<ProtectedString name="Source"><![CDATA[-- Compiled with https://roblox-ts.github.io v0.2.14
-- August 26, 2019, 6:16 PM British Summer Time

return nil;
]]></ProtectedString>
							<BinaryString name="Tags"></BinaryString>
						</Properties>
					</Item>
					<Item class="ModuleScript" referent="RBX378C2D9B101444D5B64CC8D2D9E544BE">
						<Properties>
							<Content name="LinkedSource"><null></null></Content>
							<string name="Name">vehicle.module</string>
							<string name="ScriptGuid">{F50B1247-9E82-4802-B00F-7DBC5AB1F3DF}</string>
							<ProtectedString name="Source"><![CDATA[-- Compiled with https://roblox-ts.github.io v0.2.14
-- August 26, 2019, 6:16 PM British Summer Time

return nil;
]]></ProtectedString>
							<BinaryString name="Tags"></BinaryString>
						</Properties>
					</Item>
				</Item>
			</Item>
			<Item class="Folder" referent="RBXF914678EF9224821845B02075C9F0E06">
				<Properties>
					<string name="Name">modules</string>
					<BinaryString name="Tags"></BinaryString>
				</Properties>
				<Item class="Folder" referent="RBX3AB554588E014AFFAECA3513150545D3">
					<Properties>
						<string name="Name">http</string>
						<BinaryString name="Tags"></BinaryString>
					</Properties>
					<Item class="ModuleScript" referent="RBX08E6FDA3549A4BBC8B9F9138B24421D8">
						<Properties>
							<Content name="LinkedSource"><null></null></Content>
							<string name="Name">module</string>
							<string name="ScriptGuid">{BD50CD37-4B97-4551-BE2F-93469C8CDECE}</string>
							<ProtectedString name="Source"><![CDATA[-- Compiled with https://roblox-ts.github.io v0.2.14
-- August 26, 2019, 6:16 PM British Summer Time

local TS = require(game:GetService("ReplicatedStorage"):WaitForChild("rbxts_include"):WaitForChild("RuntimeLib"));
local exports = {};
local HttpService = TS.import(TS.getModule("services")).HttpService;
local Http;
do
	Http = setmetatable({}, {
		__tostring = function() return "Http" end;
	});
	Http.__index = Http;
	function Http.new(...)
		local self = setmetatable({}, Http);
		self:constructor(...);
		return self;
	end;
	function Http:constructor()
		self.requestCache = { {} };
	end;
	Http.log = TS.async(function(self, request, response, extra)
		local logResponse = {
			time = tick();
			request = request;
			response = response;
			extra = extra;
		};
		local _0 = self.requestCache;
		_0[#_0 + 1] = logResponse;
	end);
	Http.request = TS.async(function(self, request, extra)
		local response = HttpService:RequestAsync(request);
		self:log(request, response, extra);
		return response;
	end);
end;
exports.default = Http.new();
return exports;
]]></ProtectedString>
							<BinaryString name="Tags"></BinaryString>
						</Properties>
					</Item>
				</Item>
				<Item class="Folder" referent="RBX2DB90349E0C64A4ABA9553D08D46CA87">
					<Properties>
						<string name="Name">player</string>
						<BinaryString name="Tags"></BinaryString>
					</Properties>
					<Item class="ModuleScript" referent="RBX64F774833AB645CCB100D4F97682D6A4">
						<Properties>
							<Content name="LinkedSource"><null></null></Content>
							<string name="Name">module</string>
							<string name="ScriptGuid">{B410E488-E7D1-443D-93B9-A52DEB1B0A6C}</string>
							<ProtectedString name="Source"><![CDATA[-- Compiled with https://roblox-ts.github.io v0.2.14
-- August 26, 2019, 6:16 PM British Summer Time

local TS = require(game:GetService("ReplicatedStorage"):WaitForChild("rbxts_include"):WaitForChild("RuntimeLib"));
local exports = {};
local fetchPlayer = TS.import(game:GetService("ServerScriptService"), "TS", "data", "metrosAPI", "fetchPlayer", "module").default;
local UserStore = TS.import(game:GetService("ServerScriptService"), "TS", "data", "stores", "userData", "module").default;
local graphTypes = TS.import(game:GetService("ServerScriptService"), "TS", "data", "types", "graph", "module");
local characterEnum = TS.import(game:GetService("ServerScriptService"), "TS", "data", "enums", "player", "module").character;
local PlayerManager;
do
	PlayerManager = setmetatable({}, {
		__tostring = function() return "PlayerManager" end;
	});
	PlayerManager.__index = PlayerManager;
	function PlayerManager.new(...)
		local self = setmetatable({}, PlayerManager);
		self:constructor(...);
		return self;
	end;
	function PlayerManager:constructor(player, ready)
		self.playerRef = player;
		fetchPlayer(player):andThen(function(playerData)
			UserStore:addPlayer(player.UserId, playerData);
			ready();
		end);
	end;
	PlayerManager.getVehicles = TS.async(function(self)
		local userData = TS.await(UserStore:getPlayer(self.playerRef.UserId));
		if userData and userData.vehicles then
			return userData.vehicles;
		end;
	end);
	PlayerManager.getCharacter = TS.async(function(self)
		local char = self.playerRef.Character;
		if char ~= nil then
			return char;
		else
			return characterEnum.CHARACTER_DOES_NOT_EXIST;
		end;
	end);
	PlayerManager.getHumanoid = TS.async(function(self)
		local char = TS.await(self:getCharacter());
		local humanoid = char:WaitForChild("Humanoid", 5);
		if char and humanoid then
			return humanoid;
		else
			return characterEnum.HUMANOID_DOES_NOT_EXIST;
		end;
	end);
	function PlayerManager:character()
		return {
			respawn = TS.async(function()
				self.playerRef:LoadCharacter();
			end);
			kill = TS.async(function()
				local humanoid = TS.await(self:getHumanoid());
				if humanoid then
					humanoid.Health = 0;
					if humanoid.Health <= 0 then
						return true;
					else
						return characterEnum.FAILED_TO_SET_HEALTH;
					end;
				else
					return characterEnum.HUMANOID_DOES_NOT_EXIST;
				end;
			end);
			teleport = TS.async(function(position)
				local char = TS.await(self:getCharacter());
				char:MoveTo(position);
				if char.PrimaryPart then
					return not not ((char.PrimaryPart.Position.X - position.X < 10) and (char.PrimaryPart.Position.Z - position.Z < 10));
				else
				end;
			end);
			damage = TS.async(function(amount)
				local humanoid = TS.await(self:getHumanoid());
				humanoid:TakeDamage(amount);
			end);
		};
	end;
	PlayerManager.getBanks = TS.async(function(self)
		local userData = TS.await(UserStore:getPlayer(self.playerRef.UserId));
		if userData and userData.banks then
			return userData.banks;
		end;
	end);
	PlayerManager.getCrimes = TS.async(function(self)
		local userData = TS.await(UserStore:getPlayer(self.playerRef.UserId));
		if userData and userData.banks then
			return userData.banks;
		end;
	end);
end;
exports.default = PlayerManager;
return exports;
]]></ProtectedString>
							<BinaryString name="Tags"></BinaryString>
						</Properties>
					</Item>
				</Item>
				<Item class="Folder" referent="RBX270C747C2E964D5D97BA28E5CDE17FB0">
					<Properties>
						<string name="Name">vehicles</string>
						<BinaryString name="Tags"></BinaryString>
					</Properties>
					<Item class="ModuleScript" referent="RBXBD1B447CE5754CD498D6F3208CFF5BB8">
						<Properties>
							<Content name="LinkedSource"><null></null></Content>
							<string name="Name">module</string>
							<string name="ScriptGuid">{E3213608-09F5-422A-9DAF-DC8D89F3F2C0}</string>
							<ProtectedString name="Source"><![CDATA[-- Compiled with https://roblox-ts.github.io v0.2.14
-- August 26, 2019, 6:16 PM British Summer Time

local TS = require(game:GetService("ReplicatedStorage"):WaitForChild("rbxts_include"):WaitForChild("RuntimeLib"));
local exports = {};
local userStore = TS.import(game:GetService("ServerScriptService"), "TS", "data", "stores", "userData", "module").default;
local _0 = TS.import(game:GetService("ServerScriptService"), "TS", "data", "enums", "vehicle");
local vehicleAuthorisationEnum, vehicleErrorEnum = _0.vehicleAuthorisationEnum, _0.vehicleErrorEnum;
local vehicle;
do
	vehicle = setmetatable({}, {
		__tostring = function() return "vehicle" end;
	});
	vehicle.__index = vehicle;
	function vehicle.new(...)
		local self = setmetatable({}, vehicle);
		self:constructor(...);
		return self;
	end;
	function vehicle:constructor(vehicle)
		self.vehicleId = "";
		self.state = {
			locked = true;
		};
		self.VehicleData = vehicle;
	end;
	function vehicle:checkAuthorisation(player)
		local PlayerData = userStore:getPlayer(player.UserId);
		if PlayerData then
			if self.VehicleData.owner_player == PlayerData.id then
				return vehicleAuthorisationEnum.ALL;
			else
				return vehicleAuthorisationEnum.NONE;
			end;
		end;
	end;
	function vehicle:setLocked(lock, player)
		if self:checkAuthorisation(player) == vehicleAuthorisationEnum.ALL then
			self.state.locked = lock;
			return self:getLocked();
		else
			return vehicleErrorEnum.AUTHENTICATION_FAILED;
		end;
	end;
	function vehicle:getLocked()
		return self.state.locked;
	end;
end;
exports.default = vehicle;
return exports;
]]></ProtectedString>
							<BinaryString name="Tags"></BinaryString>
						</Properties>
					</Item>
				</Item>
			</Item>
		</Item>
	</Item>
	<Item class="ServerStorage" referent="RBX296D440F875E47569381BC50D84D541A">
		<Properties>
			<string name="Name">ServerStorage</string>
			<BinaryString name="Tags"></BinaryString>
		</Properties>
	</Item>
	<Item class="ReplicatedStorage" referent="0">
		<Properties>
			<string name="Name">ReplicatedStorage</string>
			<BinaryString name="Tags"></BinaryString>
		</Properties>
		<Item class="Folder" referent="1">
			<Properties>
				<string name="Name">TS</string>
				<BinaryString name="Tags"></BinaryString>
			</Properties>
			<Item class="ModuleScript" referent="2">
				<Properties>
					<Content name="LinkedSource"><null></null></Content>
					<string name="Name">module</string>
					<string name="ScriptGuid">{2EE22979-F92D-432A-9710-852A08E324BB}</string>
					<ProtectedString name="Source"><![CDATA[-- Compiled with https://roblox-ts.github.io v0.2.14
-- August 26, 2019, 6:16 PM British Summer Time

local exports = {};
local function makeHello(name)
	return "Hello from " .. name .. "!";
end;
exports.makeHello = makeHello;
return exports;
]]></ProtectedString>
					<BinaryString name="Tags"></BinaryString>
				</Properties>
			</Item>
		</Item>
		<Item class="Folder" referent="3">
			<Properties>
				<string name="Name">rbxts_include</string>
				<BinaryString name="Tags"></BinaryString>
			</Properties>
			<Item class="ModuleScript" referent="4">
				<Properties>
					<Content name="LinkedSource"><null></null></Content>
					<string name="Name">Promise</string>
					<string name="ScriptGuid">{A40473EB-B68D-404B-AFF1-DFBFA6F1EB97}</string>
					<ProtectedString name="Source"><![CDATA[--[[
	An implementation of Promises similar to Promise/A+.
	Forked from LPGhatguy/roblox-lua-promise, modified for roblox-ts.
]]

local PROMISE_DEBUG = false

--[[
	Packs a number of arguments into a table and returns its length.

	Used to cajole varargs without dropping sparse values.
]]
local function pack(...)
	local len = select("#", ...)

	return len, { ... }
end

--[[
	wpcallPacked is a version of xpcall that:
	* Returns the length of the result first
	* Returns the result packed into a table
	* Passes extra arguments through to the passed function; xpcall doesn't
	* Issues a warning if PROMISE_DEBUG is enabled
]]
local function wpcallPacked(f, ...)
	local argsLength, args = pack(...)

	local body = function()
		return f(unpack(args, 1, argsLength))
	end

	local resultLength, result = pack(xpcall(body, debug.traceback))

	-- If promise debugging is on, warn whenever a pcall fails.
	-- This is useful for debugging issues within the Promise implementation
	-- itself.
	if PROMISE_DEBUG and not result[1] then
		warn(result[2])
	end

	return resultLength, result
end

--[[
	Creates a function that invokes a callback with correct error handling and
	resolution mechanisms.
]]
local function createAdvancer(callback, resolve, reject)
	return function(...)
		local resultLength, result = wpcallPacked(callback, ...)
		local ok = result[1]

		if ok then
			resolve(unpack(result, 2, resultLength))
		else
			reject(unpack(result, 2, resultLength))
		end
	end
end

local function isEmpty(t)
	return next(t) == nil
end

local function createSymbol(name)
	assert(type(name) == "string", "createSymbol requires `name` to be a string.")

	local symbol = newproxy(true)

	getmetatable(symbol).__tostring = function()
		return ("Symbol(%s)"):format(name)
	end

	return symbol
end

local PromiseMarker = createSymbol("PromiseMarker")

local Promise = {}
Promise.prototype = {}
Promise.__index = Promise.prototype

Promise.Status = {
	Started = createSymbol("Started"),
	Resolved = createSymbol("Resolved"),
	Rejected = createSymbol("Rejected"),
	Cancelled = createSymbol("Cancelled"),
}

--[[
	Constructs a new Promise with the given initializing callback.

	This is generally only called when directly wrapping a non-promise API into
	a promise-based version.

	The callback will receive 'resolve' and 'reject' methods, used to start
	invoking the promise chain.

	For example:

		local function get(url)
			return Promise.new(function(resolve, reject)
				spawn(function()
					resolve(HttpService:GetAsync(url))
				end)
			end)
		end

		get("https://google.com")
			:andThen(function(stuff)
				print("Got some stuff!", stuff)
			end)

	Second parameter, parent, is used internally for tracking the "parent" in a
	promise chain. External code shouldn't need to worry about this.
]]
function Promise.new(callback, parent)
	if parent ~= nil and not Promise.is(parent) then
		error("Argument #2 to Promise.new must be a promise or nil", 2)
	end

	local self = {
		-- Used to locate where a promise was created
		_source = debug.traceback(),

		-- A tag to identify us as a promise
		[PromiseMarker] = true,

		_status = Promise.Status.Started,

		-- A table containing a list of all results, whether success or failure.
		-- Only valid if _status is set to something besides Started
		_values = nil,

		-- Lua doesn't like sparse arrays very much, so we explicitly store the
		-- length of _values to handle middle nils.
		_valuesLength = -1,

		-- If an error occurs with no observers, this will be set.
		_unhandledRejection = false,

		-- Queues representing functions we should invoke when we update!
		_queuedResolve = {},
		_queuedReject = {},
		_queuedFinally = {},

		-- The function to run when/if this promise is cancelled.
		_cancellationHook = nil,

		-- The "parent" of this promise in a promise chain. Required for
		-- cancellation propagation.
		_parent = parent,

		-- The number of consumers attached to this promise. This is needed so that
		-- we don't propagate promise cancellations when there are still uncancelled
		-- consumers.
		_numConsumers = 0,
	}

	setmetatable(self, Promise)

	local function resolve(...)
		self:_resolve(...)
	end

	local function reject(...)
		self:_reject(...)
	end

	local function onCancel(cancellationHook)
		assert(type(cancellationHook) == "function", "onCancel must be called with a function as its first argument.")

		if self._status == Promise.Status.Cancelled then
			cancellationHook()
		else
			self._cancellationHook = cancellationHook
		end
	end

	local _, result = wpcallPacked(callback, resolve, reject, onCancel)
	local ok = result[1]
	local err = result[2]

	if not ok and self._status == Promise.Status.Started then
		reject(err)
	end

	return self
end

--[[
	Fast spawn: Spawns a thread with predictable timing.
	Runs immediately instead of first cycle being deferred.
]]
local spawnBindable = Instance.new("BindableEvent")
function Promise.spawn(callback, ...)
	local args = { ... }
	local length = select("#", ...)
	local connection = spawnBindable.Event:Connect(function()
		callback(unpack(args, 1, length))
	end)
	spawnBindable:Fire()
	connection:Disconnect()
end

--[[
	Create a promise that represents the immediately resolved value.
]]
function Promise.resolve(value)
	return Promise.new(function(resolve)
		resolve(value)
	end)
end

--[[
	Create a promise that represents the immediately rejected value.
]]
function Promise.reject(value)
	return Promise.new(function(_, reject)
		reject(value)
	end)
end

--[[
	Returns a new promise that:
		* is resolved when all input promises resolve
		* is rejected if ANY input promises reject
]]
function Promise.all(promises)
	if type(promises) ~= "table" then
		error("Please pass a list of promises to Promise.all", 2)
	end

	-- If there are no values then return an already resolved promise.
	if #promises == 0 then
		return Promise.resolve({})
	end

	-- We need to check that each value is a promise here so that we can produce
	-- a proper error rather than a rejected promise with our error.
	for i = 1, #promises do
		if not Promise.is(promises[i]) then
			error(("Non-promise value passed into Promise.all at index #%d"):format(i), 2)
		end
	end

	return Promise.new(function(resolve, reject)
		-- An array to contain our resolved values from the given promises.
		local resolvedValues = {}

		-- Keep a count of resolved promises because just checking the resolved
		-- values length wouldn't account for promises that resolve with nil.
		local resolvedCount = 0

		-- Called when a single value is resolved and resolves if all are done.
		local function resolveOne(i, ...)
			resolvedValues[i] = ...
			resolvedCount = resolvedCount + 1

			if resolvedCount == #promises then
				resolve(resolvedValues)
			end
		end

		-- We can assume the values inside `promises` are all promises since we
		-- checked above.
		for i = 1, #promises do
			promises[i]:andThen(
				function(...)
					resolveOne(i, ...)
				end,
				function(...)
					reject(...)
				end
			)
		end
	end)
end

--[[
	Is the given object a Promise instance?
]]
function Promise.is(object)
	if type(object) ~= "table" then
		return false
	end

	return object[PromiseMarker] == true
end

function Promise.prototype:getStatus()
	return self._status
end

function Promise.prototype:isRejected()
	return self._status == Promise.Status.Rejected
end

function Promise.prototype:isResolved()
	return self._status == Promise.Status.Resolved
end

function Promise.prototype:isPending()
	return self._status == Promise.Status.Started
end

function Promise.prototype:isCancelled()
	return self._status == Promise.Status.Cancelled
end

--[[
	Creates a new promise that receives the result of this promise.

	The given callbacks are invoked depending on that result.
]]
function Promise.prototype:andThen(successHandler, failureHandler)
	self._unhandledRejection = false
	self._numConsumers = self._numConsumers + 1

	-- Create a new promise to follow this part of the chain
	return Promise.new(function(resolve, reject)
		-- Our default callbacks just pass values onto the next promise.
		-- This lets success and failure cascade correctly!

		local successCallback = resolve
		if successHandler then
			successCallback = createAdvancer(successHandler, resolve, reject)
		end

		local failureCallback = reject
		if failureHandler then
			failureCallback = createAdvancer(failureHandler, resolve, reject)
		end

		if self._status == Promise.Status.Started then
			-- If we haven't resolved yet, put ourselves into the queue
			table.insert(self._queuedResolve, successCallback)
			table.insert(self._queuedReject, failureCallback)
		elseif self._status == Promise.Status.Resolved then
			-- This promise has already resolved! Trigger success immediately.
			successCallback(unpack(self._values, 1, self._valuesLength))
		elseif self._status == Promise.Status.Rejected then
			-- This promise died a terrible death! Trigger failure immediately.
			failureCallback(unpack(self._values, 1, self._valuesLength))
		elseif self._status == Promise.Status.Cancelled then
			-- We don't want to call the success handler or the failure handler,
			-- we just reject this promise outright.
			reject("Promise is cancelled")
		end
	end, self)
end

--[[
	Used to catch any errors that may have occurred in the promise.
]]
function Promise.prototype:catch(failureCallback)
	return self:andThen(nil, failureCallback)
end

--[[
	Cancels the promise, disallowing it from rejecting or resolving, and calls
	the cancellation hook if provided.
]]
function Promise.prototype:cancel()
	if self._status ~= Promise.Status.Started then
		return
	end

	self._status = Promise.Status.Cancelled

	if self._cancellationHook then
		self._cancellationHook()
	end

	if self._parent then
		self._parent:_consumerCancelled()
	end

	self:_finalize()
end

--[[
	Used to decrease the number of consumers by 1, and if there are no more,
	cancel this promise.
]]
function Promise.prototype:_consumerCancelled()
	self._numConsumers = self._numConsumers - 1

	if self._numConsumers <= 0 then
		self:cancel()
	end
end

--[[
	Used to set a handler for when the promise resolves, rejects, or is
	cancelled. Returns a new promise chained from this promise.
]]
function Promise.prototype:finally(finallyHandler)
	self._numConsumers = self._numConsumers + 1

	-- Return a promise chained off of this promise
	return Promise.new(function(resolve, reject)
		local finallyCallback = resolve
		if finallyHandler then
			finallyCallback = createAdvancer(finallyHandler, resolve, reject)
		end

		if self._status == Promise.Status.Started then
			-- The promise is not settled, so queue this.
			table.insert(self._queuedFinally, finallyCallback)
		else
			-- The promise already settled or was cancelled, run the callback now.
			finallyCallback()
		end
	end, self)
end

--[[
	Yield until the promise is completed.

	This matches the execution model of normal Roblox functions.
]]
function Promise.prototype:await()
	self._unhandledRejection = false

	if self._status == Promise.Status.Started then
		local result
		local resultLength
		local bindable = Instance.new("BindableEvent")

		self:andThen(
			function(...)
				resultLength, result = pack(...)
				bindable:Fire(true)
			end,
			function(...)
				resultLength, result = pack(...)
				bindable:Fire(false)
			end
		)
		self:finally(function()
			bindable:Fire(nil)
		end)

		local ok = bindable.Event:Wait()
		bindable:Destroy()

		if ok == nil then
			-- If cancelled, we return nil.
			return nil
		end

		return ok, unpack(result, 1, resultLength)
	elseif self._status == Promise.Status.Resolved then
		return true, unpack(self._values, 1, self._valuesLength)
	elseif self._status == Promise.Status.Rejected then
		return false, unpack(self._values, 1, self._valuesLength)
	end

	-- If the promise is cancelled, fall through to nil.
	return nil
end

--[[
	Intended for use in tests.

	Similar to await(), but instead of yielding if the promise is unresolved,
	_unwrap will throw. This indicates an assumption that a promise has
	resolved.
]]
function Promise.prototype:_unwrap()
	if self._status == Promise.Status.Started then
		error("Promise has not resolved or rejected.", 2)
	end

	local success = self._status == Promise.Status.Resolved

	return success, unpack(self._values, 1, self._valuesLength)
end

function Promise.prototype:_resolve(...)
	if self._status ~= Promise.Status.Started then
		return
	end

	-- If the resolved value was a Promise, we chain onto it!
	if Promise.is((...)) then
		-- Without this warning, arguments sometimes mysteriously disappear
		if select("#", ...) > 1 then
			local message = (
				"When returning a Promise from andThen, extra arguments are " ..
				"discarded! See:\n\n%s"
			):format(
				self._source
			)
			warn(message)
		end

		(...):andThen(
			function(...)
				self:_resolve(...)
			end,
			function(...)
				self:_reject(...)
			end
		)

		return
	end

	self._status = Promise.Status.Resolved
	self._valuesLength, self._values = pack(...)

	-- We assume that these callbacks will not throw errors.
	for _, callback in ipairs(self._queuedResolve) do
		callback(...)
	end

	self:_finalize()
end

function Promise.prototype:_reject(...)
	if self._status ~= Promise.Status.Started then
		return
	end

	self._status = Promise.Status.Rejected
	self._valuesLength, self._values = pack(...)

	-- If there are any rejection handlers, call those!
	if not isEmpty(self._queuedReject) then
		-- We assume that these callbacks will not throw errors.
		for _, callback in ipairs(self._queuedReject) do
			callback(...)
		end
	else
		-- At this point, no one was able to observe the error.
		-- An error handler might still be attached if the error occurred
		-- synchronously. We'll wait one tick, and if there are still no
		-- observers, then we should put a message in the console.

		self._unhandledRejection = true
		local err = tostring((...))

		spawn(function()
			-- Someone observed the error, hooray!
			if not self._unhandledRejection then
				return
			end

			-- Build a reasonable message
			local message = ("Unhandled promise rejection:\n\n%s\n\n%s"):format(
				err,
				self._source
			)
			warn(message)
		end)
	end

	self:_finalize()
end

--[[
	Calls any :finally handlers. We need this to be a separate method and
	queue because we must call all of the finally callbacks upon a success,
	failure, *and* cancellation.
]]
function Promise.prototype:_finalize()
	for _, callback in ipairs(self._queuedFinally) do
		-- Purposefully not passing values to callbacks here, as it could be the
		-- resolved values, or rejected errors. If the developer needs the values,
		-- they should use :andThen or :catch explicitly.
		callback()
	end
end

return Promise
]]></ProtectedString>
					<BinaryString name="Tags"></BinaryString>
				</Properties>
			</Item>
			<Item class="ModuleScript" referent="5">
				<Properties>
					<Content name="LinkedSource"><null></null></Content>
					<string name="Name">RuntimeLib</string>
					<string name="ScriptGuid">{CC6DE76A-563A-4E7A-8C2C-6F17EC9D3DE1}</string>
					<ProtectedString name="Source"><![CDATA[local Promise = require(script.Parent.Promise)

local HttpService = game:GetService("HttpService")

-- constants
local table_sort = table.sort
local table_concat = table.concat
local math_ceil = math.ceil
local math_floor = math.floor

local TS = {}

-- runtime classes
TS.Promise = Promise

local Symbol do
	Symbol = {}
	Symbol.__index = Symbol
	setmetatable(Symbol, {
		__call = function(_, description)
			local self = setmetatable({}, Symbol)
			self.description = "Symbol(" .. (description or "") .. ")"
			return self
		end
	})

	local symbolRegistry = setmetatable({}, {
		__index = function(self, k)
			self[k] = Symbol(k)
			return self[k]
		end
	})

	function Symbol:toString()
		return self.description
	end

	Symbol.__tostring = Symbol.toString

	-- Symbol.for
	function Symbol.getFor(key)
		return symbolRegistry[key]
	end

	function Symbol.keyFor(goalSymbol)
		for key, symbol in pairs(symbolRegistry) do
			if symbol == goalSymbol then
				return key
			end
		end
	end
end

TS.Symbol = Symbol
TS.Symbol_iterator = Symbol("Symbol.iterator")

-- module resolution
local globalModules = script.Parent:FindFirstChild("node_modules")

function TS.getModule(moduleName)
	local object = getfenv(2).script.Parent
	if not globalModules then
		error("Could not find any modules!", 2)
	end
	if object:IsDescendantOf(globalModules) then
		while object.Parent do
			local modules = object:FindFirstChild("node_modules")
			if modules then
				local module = modules:FindFirstChild(moduleName)
				if module then
					return module
				end
			end
			object = object.Parent
		end
	else
		local module = globalModules:FindFirstChild(moduleName)
		if module then
			return module
		end
	end
	error("Could not find module: " .. moduleName, 2)
end

-- This is a hash which TS.import uses as a kind of linked-list-like history of [Script who Loaded] -> Library
local loadedLibraries = {}
local currentlyLoading = {}

function TS.import(module, ...)
	for i = 1, select("#", ...) do
		module = module:WaitForChild((select(i, ...)))
	end

	if module.ClassName == "ModuleScript" then
		local data = loadedLibraries[module]

		if data == nil then
			-- If called from command bar, use table as a reference (this is never concatenated)
			local caller = getfenv(0).script or { Name = "Command bar" }
			currentlyLoading[caller] = module

			-- Check to see if a case like this occurs:
			-- module -> Module1 -> Module2 -> module

			-- WHERE currentlyLoading[module] is Module1
			-- and currentlyLoading[Module1] is Module2
			-- and currentlyLoading[Module2] is module

			local currentModule = module
			local depth = 0

			while currentModule do
				depth = depth + 1
				currentModule = currentlyLoading[currentModule]

				if currentModule == module then
					local str = currentModule.Name -- Get the string traceback

					for _ = 1, depth do
						currentModule = currentlyLoading[currentModule]
						str = str .. " -> " .. currentModule.Name
					end

					error("Failed to import! Detected a circular dependency chain: " .. str, 2)
				end
			end

			assert(_G[module] == nil, "Invalid module access!")
			_G[module] = TS
			data = { value = require(module) }

			if currentlyLoading[caller] == module then -- Thread-safe cleanup!
				currentlyLoading[caller] = nil
			end

			loadedLibraries[module] = data -- Cache for subsequent calls
		end

		return data.value
	else
		error("Failed to import! Expected ModuleScript, got " .. module.ClassName, 2)
	end
end

function TS.exportNamespace(module, ancestor)
	for key, value in pairs(module) do
		ancestor[key] = value
	end
end

-- general utility functions
function TS.instanceof(obj, class)
	-- custom Class.instanceof() check
	if type(class) == "table" and type(class.instanceof) == "function" then
		return class.instanceof(obj)
	end

	-- metatable check
	if type(obj) == "table" then
		obj = getmetatable(obj)
		while obj ~= nil do
			if obj == class then
				return true
			end
			local mt = getmetatable(obj)
			if mt then
				obj = mt.__index
			else
				obj = nil
			end
		end
	end

	return false
end

function TS.async(callback)
	return function(...)
		local n = select("#", ...)
		local args = { ... }
		return Promise.new(function(resolve, reject)
			coroutine.wrap(function()
				local ok, result = pcall(callback, unpack(args, 1, n))
				if ok then
					resolve(result)
				else
					reject(result)
				end
			end)()
		end)
	end
end

function TS.await(promise)
	if not Promise.is(promise) then
		return promise
	end

	local ok, result = promise:await()
	if ok then
		return result
	else
		TS.throw(ok == nil and "The awaited Promise was cancelled" or result)
	end
end

function TS.add(a, b)
	if type(a) == "string" or type(b) == "string" then
		return a .. b
	else
		return a + b
	end
end

local function bitTruncate(a)
	if a < 0 then
		return math_ceil(a)
	else
		return math_floor(a)
	end
end

TS.bit_truncate = bitTruncate

-- bitwise operations
local powOfTwo = setmetatable({}, {
	__index = function(self, i)
		local v = 2 ^ i
		self[i] = v
		return v
	end;
})

local _2_52 = powOfTwo[52]
local function bitop(a, b, oper)
	local r, m, s = 0, _2_52
	repeat
		s, a, b = a + b + m, a % m, b % m
		r, m = r + m * oper % (s - a - b), m / 2
	until m < 1
	return r
end

function TS.bit_not(a)
	return -a - 1
end

function TS.bit_or(a, b)
	a = bitTruncate(tonumber(a))
	b = bitTruncate(tonumber(b))
	return bitop(a, b, 1)
end

function TS.bit_and(a, b)
	a = bitTruncate(tonumber(a))
	b = bitTruncate(tonumber(b))
	return bitop(a, b, 4)
end

function TS.bit_xor(a, b)
	a = bitTruncate(tonumber(a))
	b = bitTruncate(tonumber(b))
	return bitop(a, b, 3)
end

function TS.bit_lsh(a, b)
	a = bitTruncate(tonumber(a))
	b = bitTruncate(tonumber(b))
	return a * powOfTwo[b]
end

function TS.bit_rsh(a, b)
	a = bitTruncate(tonumber(a))
	b = bitTruncate(tonumber(b))
	return bitTruncate(a / powOfTwo[b])
end

function TS.bit_lrsh(a, b)
	a = bitTruncate(tonumber(a))
	b = bitTruncate(tonumber(b))
	if a >= 0 then return TS.bit_rsh(a, b) end
	return TS.bit_rsh((a % powOfTwo[32]), b)
end

-- utility functions
local function copy(object)
	local result = {}
	for k, v in pairs(object) do
		result[k] = v
	end
	return result
end

local function deepCopy(object)
	local result = {}
	for k, v in pairs(object) do
		if type(v) == "table" then
			result[k] = deepCopy(v)
		else
			result[k] = v
		end
	end
	return result
end

local function deepEquals(a, b)
	-- a[k] == b[k]
	for k in pairs(a) do
		local av = a[k]
		local bv = b[k]
		if type(av) == "table" and type(bv) == "table" then
			local result = deepEquals(av, bv)
			if not result then
				return false
			end
		elseif av ~= bv then
			return false
		end
	end

	-- extra keys in b
	for k in pairs(b) do
		if a[k] == nil then
			return false
		end
	end

	return true
end

-- Object static functions

function TS.Object_keys(object)
	local result = {}
	for key in pairs(object) do
		result[#result + 1] = key
	end
	return result
end

function TS.Object_values(object)
	local result = {}
	for _, value in pairs(object) do
		result[#result + 1] = value
	end
	return result
end

function TS.Object_entries(object)
	local result = {}
	for key, value in pairs(object) do
		result[#result + 1] = { key, value }
	end
	return result
end

function TS.Object_assign(toObj, ...)
	for i = 1, select("#", ...) do
		local arg = select(i, ...)
		if type(arg) == "table" then
			for key, value in pairs(arg) do
				toObj[key] = value
			end
		end
	end
	return toObj
end

TS.Object_copy = copy

TS.Object_deepCopy = deepCopy

TS.Object_deepEquals = deepEquals

local function toString(data)
	return HttpService:JSONEncode(data)
end

TS.Object_toString = toString

-- string macro functions
function TS.string_find_wrap(a, b, ...)
	if a then
		return a - 1, b - 1, ...
	end
end

-- array macro functions
local function array_copy(list)
	local result = {}
	for i = 1, #list do
		result[i] = list[i]
	end
	return result
end

TS.array_copy = array_copy

function TS.array_entries(list)
	local result = {}
	for key = 1, #list do
		result[key] = { key - 1, list[key] }
	end
	return result
end

function TS.array_forEach(list, callback)
	for i = 1, #list do
		local v = list[i]
		if v ~= nil then
			callback(v, i - 1, list)
		end
	end
end

function TS.array_map(list, callback)
	local result = {}
	for i = 1, #list do
		local v = list[i]
		if v ~= nil then
			result[i] = callback(v, i - 1, list)
		end
	end
	return result
end

function TS.array_filter(list, callback)
	local result = {}
	for i = 1, #list do
		local v = list[i]
		if v ~= nil and callback(v, i - 1, list) == true then
			result[#result + 1] = v
		end
	end
	return result
end

local function sortFallback(a, b)
	return tostring(a) < tostring(b)
end

function TS.array_sort(list, callback)
	local sorted = array_copy(list)

	if callback then
		table_sort(sorted, function(a, b)
			return 0 < callback(a, b)
		end)
	else
		table_sort(sorted, sortFallback)
	end

	return sorted
end

TS.array_toString = toString

function TS.array_slice(list, startI, endI)
	local length = #list

	if startI == nil then startI = 0 end
	if endI == nil then endI = length end

	if startI < 0 then startI = length + startI end
	if endI < 0 then endI = length + endI end

	local result = {}

	for i = startI + 1, endI do
		result[i - startI] = list[i]
	end

	return result
end

function TS.array_splice(list, start, deleteCount, ...)
	local len = #list
	local actualStart
	if start < 0 then
		actualStart = len + start
		if actualStart < 0 then
			actualStart = 0
		end
	else
		if start < len then
			actualStart = start
		else
			actualStart = len
		end
	end
	local items = { ... }
	local itemCount = #items
	local actualDeleteCount
	if start == nil then
		actualDeleteCount = 0
	elseif deleteCount == nil then
		actualDeleteCount = len - actualStart
	else
		if deleteCount < 0 then
			deleteCount = 0
		end
		actualDeleteCount = len - actualStart
		if deleteCount < actualDeleteCount then
			actualDeleteCount = deleteCount
		end
	end
	local out = {}
	local k = 0
	while k < actualDeleteCount do
		local from = actualStart + k
		if list[from + 1] then
			out[k + 1] = list[from + 1]
		end
		k = k + 1
	end
	if itemCount < actualDeleteCount then
		k = actualStart
		while k < len - actualDeleteCount do
			local from = k + actualDeleteCount
			local to = k + itemCount
			if list[from + 1] then
				list[to + 1] = list[from + 1]
			else
				list[to + 1] = nil
			end
			k = k + 1
		end
		k = len
		while k > len - actualDeleteCount + itemCount do
			list[k] = nil
			k = k - 1
		end
	elseif itemCount > actualDeleteCount then
		k = len - actualDeleteCount
		while k > actualStart do
			local from = k + actualDeleteCount
			local to = k + itemCount
			if list[from] then
				list[to] = list[from]
			else
				list[to] = nil
			end
			k = k - 1
		end
	end
	k = actualStart
	for i = 1, #items do
		list[k + 1] = items[i]
		k = k + 1
	end
	k = #list
	while k > len - actualDeleteCount + itemCount do
		list[k] = nil
		k = k - 1
	end
	return out
end

function TS.array_some(list, callback)
	for i = 1, #list do
		local v = list[i]
		if v ~= nil and callback(v, i - 1, list) == true then
			return true
		end
	end
	return false
end

function TS.array_every(list, callback)
	for i = 1, #list do
		local v = list[i]
		if v ~= nil and callback(v, i - 1, list) == false then
			return false
		end
	end
	return true
end

function TS.array_includes(list, item, startingIndex)
	for i = (startingIndex or 0) + 1, #list do
		if list[i] == item then
			return true
		end
	end
	return false
end

function TS.array_indexOf(list, value, fromIndex)
	for i = (fromIndex or 0) + 1, #list do
		if value == list[i] then
			return i - 1
		end
	end
	return -1
end

function TS.array_lastIndexOf(list, value, fromIndex)
	for i = (fromIndex or #list - 1) + 1, 1, -1 do
		if value == list[i] then
			return i - 1
		end
	end
	return -1
end

function TS.array_reverse(list)
	local result = {}
	local length = #list
	local n = length + 1
	for i = 1, length do
		result[i] = list[n - i]
	end
	return result
end

function TS.array_reduce(list, callback, initialValue)
	local start = 1
	if initialValue == nil then
		initialValue = list[start]
		start = 2
	end
	local accumulator = initialValue
	for i = start, #list do
		local v = list[i]
		if v ~= nil then
			accumulator = callback(accumulator, v, i)
		end
	end
	return accumulator
end

function TS.array_reduceRight(list, callback, initialValue)
	local start = #list
	if initialValue == nil then
		initialValue = list[start]
		start = start - 1
	end
	local accumulator = initialValue
	for i = start, 1, -1 do
		local v = list[i]
		if v ~= nil then
			accumulator = callback(accumulator, v, i)
		end
	end
	return accumulator
end

function TS.array_unshift(list, ...)
	local n = #list
	local argsLength = select("#", ...)
	for i = n, 1, -1 do
		list[i + argsLength] = list[i]
	end
	for i = 1, argsLength do
		list[i] = select(i, ...)
	end
	return n + argsLength
end

local function array_push_apply(list, ...)
	local len = #list
	for i = 1, select("#", ...) do
		local list2 = select(i, ...)
		local len2 = #list2
		for j = 1, len2 do
			list[len + j] = list2[j]
		end
		len = len + len2
	end
	return len
end

TS.array_push_apply = array_push_apply

function TS.array_push_stack(list, ...)
	local len = #list
	local len2 = select("#", ...)
	for i = 1, len2 do
		list[len + i] = select(i, ...)
	end
	return len + len2
end

function TS.array_concat(...)
	local result = {}
	array_push_apply(result, ...)
	return result
end

function TS.array_join(list, separator)
	local result = {}
	for i = 1, #list do
		local item = list[i]
		if item == nil then
			result[i] = ""
		else
			result[i] = tostring(list[i])
		end
	end
	return table_concat(result, separator or ",")
end

function TS.array_find(list, callback)
	for i = 1, #list do
		local v = list[i]
		if callback(v, i - 1, list) == true then
			return v
		end
	end
end

function TS.array_findIndex(list, callback)
	for i = 0, #list - 1 do
		if callback(list[i + 1], i, list) == true then
			return i
		end
	end
	return -1
end

local function array_flat_helper(list, depth, count, result)
	for i = 1, #list do
		local v = list[i]

		if v ~= nil then
			if type(v) == "table" then
				if depth ~= 0 then
					count = array_flat_helper(v, depth - 1, count, result)
				else
					count = count + 1
					result[count] = v
				end
			else
				count = count + 1
				result[count] = v
			end
		end
	end

	return count
end

function TS.array_flat(list, depth)
	local result = {}
	array_flat_helper(list, depth or 1, 0, result)
	return result
end

function TS.array_fill(list, value, from, to)
	local length = #list

	if from == nil then
		from = 0
	elseif from < 0 then
		from = from + length
	end

	if to == nil or to > length then
		to = length
	elseif to < 0 then
		to = to + length
	end

	for i = from + 1, to do
		list[i] = value
	end

	return list
end

function TS.array_copyWithin(list, target, from, to)
	local length = #list

	if target < 0 then
		target = target + length
	end

	if from == nil then
		from = 0
	elseif from < 0 then
		from = from + length
	end

	if to == nil or to > length then
		to = length
	elseif to < 0 then
		to = to + length
	end

	local tf = target - from
	local overshoot = to + tf - length

	if overshoot > 0 then
		to = from + length - target
	end

	for i = to, from + 1, -1 do
		list[i + tf] = list[i]
	end

	return list
end

TS.array_deepCopy = deepCopy

TS.array_deepEquals = deepEquals

-- map macro functions

function TS.map_new(pairs)
	local result = {}
	for i = 1, #pairs do
		local pair = pairs[i]
		result[pair[1]] = pair[2]
	end
	return result
end

function TS.map_clear(map)
	for key in pairs(map) do
		map[key] = nil
	end
end

local function getNumKeys(map)
	local result = 0
	for _ in pairs(map) do
		result = result + 1
	end
	return result
end

TS.map_size = getNumKeys
TS.map_entries = TS.Object_entries

function TS.map_forEach(map, callback)
	for key, value in pairs(map) do
		callback(value, key, map)
	end
end

TS.map_keys = TS.Object_keys

TS.map_values = TS.Object_values
TS.map_toString = toString

-- set macro functions

function TS.set_new(values)
	local result = {}
	for i = 1, #values do
		result[values[i]] = true
	end
	return result
end

TS.set_clear = TS.map_clear

function TS.set_forEach(set, callback)
	for key in pairs(set) do
		callback(key, key, set)
	end
end

function TS.set_union(set1, set2)
	local result = {}

	for value in pairs(set1) do
		result[value] = true
	end

	for value in pairs(set2) do
		result[value] = true
	end

	return result
end

function TS.set_intersect(set1, set2)
	local result = {}

	for value in pairs(set1) do
		if set2[value] then
			result[value] = true
		end
	end

	return result
end

function TS.set_isDisjointWith(set1, set2)
	for value in pairs(set1) do
		if set2[value] then
			return false
		end
	end
	return true
end

function TS.set_isSubsetOf(set1, set2)
	for value in pairs(set1) do
		if set2[value] == nil then
			return false
		end
	end

	return true
end

function TS.set_difference(set1, set2)
	local result = {}
	for value in pairs(set1) do
		if set2[value] == nil then
			result[value] = true
		end
	end
	return result
end

TS.set_values = TS.Object_keys

TS.set_size = getNumKeys

TS.set_toString = toString

function TS.iterableCache(iter)
	local results = {}
	local count = 0
	for _0 in iter.next do
		if _0.done then break end
		count = count + 1
		results[count] = _0.value
	end
	return results
end

local function package(...)
	return select("#", ...), {...}
end

function TS.iterableFunctionCache(iter)
	local results = {}
	local count = 0

	while true do
		local size, t = package(iter());
		if size == 0 then break end
		count = count + 1
		results[count] = t
	end

	return results
end

-- roact functions

function TS.Roact_combine(...)
	local args = { ... }
	local result = {}
	for i = 1, #args do
		for key, value in pairs(args[i]) do
			if (type(key) == "number") then
				table.insert(result, value)
			else
				result[key] = value
			end
		end
	end
	return result
end

-- opcall

function TS.opcall(func, ...)
	local success, valueOrErr = pcall(func, ...)
	if success then
		return {
			success = true,
			value = valueOrErr,
		}
	else
		return {
			success = false,
			error = valueOrErr,
		}
	end
end

-- try catch utilities

local function pack(...)
	return { size = select("#", ...), ... }
end

local throwStack = {}

function TS.throw(value)
	if #throwStack > 0 then
		throwStack[#throwStack](value)
	else
		error("Uncaught " .. tostring(value), 2)
	end
end

function TS.try(tryCallback, catchCallback)
	local done = false
	local yielded = false
	local popped = false
	local resumeThread = coroutine.running()

	local returns

	local function pop()
		if not popped then
			popped = true
			throwStack[#throwStack] = nil
		end
	end

	local function resume()
		if yielded then
			local success, errorMsg = coroutine.resume(resumeThread)
			if not success then
				warn(errorMsg)
			end
		else
			done = true
		end
	end

	local function throw(value)
		pop()
		if catchCallback then
			returns = pack(catchCallback(value))
		end
		resume()
		coroutine.yield()
	end

	throwStack[#throwStack + 1] = throw

	coroutine.wrap(function()
		returns = pack(tryCallback())
		resume()
	end)()

	if not done then
		yielded = true
		coroutine.yield()
	end

	pop()

	return returns
end

return TS
]]></ProtectedString>
					<BinaryString name="Tags"></BinaryString>
				</Properties>
			</Item>
			<Item class="Folder" referent="RBX5625F2679AB94537946EB50B6422EB43">
				<Properties>
					<string name="Name">node_modules</string>
					<BinaryString name="Tags"></BinaryString>
				</Properties>
				<Item class="ModuleScript" referent="RBXE303315FFA774376A167CD9FAF5BCC44">
					<Properties>
						<Content name="LinkedSource"><null></null></Content>
						<string name="Name">cubic-bezier</string>
						<string name="ScriptGuid">{10B27E69-7079-48AD-9E19-73856B284BDA}</string>
						<ProtectedString name="Source"><![CDATA[-- Smooth Interpolation Curve Generator
-- @author Validark
-- @original https://github.com/gre/bezier-easing
-- @testsite http://cubic-bezier.com/
-- @testsite http://greweb.me/bezier-easing-editor/example/

-- Bezier.new(x1, y1, x2, y2)
-- @param numbers (x1, y1, x2, y2) The control points of your curve
-- @returns function(t [b, c, d])
--	@param number t the time elapsed [0, d]
--	@param number b beginning value being interpolated (default = 0)
--	@param number c change in value being interpolated (equivalent to: ending - beginning) (default = 1)
--	@param number d duration interpolation is occurring over (default = 1)

-- These values are established by empiricism with tests (tradeoff: performance VS precision)
local NEWTON_ITERATIONS = 4
local NEWTON_MIN_SLOPE = 0.001
local SUBDIVISION_PRECISION = 0.0000001
local SUBDIVISION_MAX_ITERATIONS = 10
local K_SPLINE_TABLE_SIZE = 11

local K_SAMPLE_STEP_SIZE = 1 / (K_SPLINE_TABLE_SIZE - 1)

local function Linear(t, b, c, d)
	return (c or 1)*t / (d or 1) + (b or 0)
end

local Bezier = {}

function Bezier.new(x1, y1, x2, y2)
	-- TS cannot (reasonably) protect against this
	if not (0 <= x1 and x1 <= 1 and 0 <= x2 and x2 <= 1) then error("The x values must be within range [0, 1]") end

	if x1 == y1 and x2 == y2 then
		return Linear
	end

	-- Precompute redundant values
	local e, f = 3*x1, 3*x2
	local g, h, i = 1 - f + e, f - 2*e, 3*(1 - f + e)
	local j, k = 2*h, 3*y1
	local l, m = 1 - 3*y2 + k, 3*y2 - 2*k

	-- Precompute samples table
	local SampleValues = {}
	for a = 0, K_SPLINE_TABLE_SIZE - 1 do
		local z = a*K_SAMPLE_STEP_SIZE
		SampleValues[a] = ((g*z + h)*z + e)*z -- CalcBezier
	end

	return function(t, b, c, d)
		t = (c or 1)*t / (d or 1) + (b or 0)

		if t == 0 or t == 1 then -- Make sure the endpoints are correct
			return t
		end

		local CurrentSample = K_SPLINE_TABLE_SIZE - 2

		for a = 1, CurrentSample do
			if SampleValues[a] > t then
				CurrentSample = a - 1
				break
			end
		end

		-- Interpolate to provide an initial guess for t
		local IntervalStart = CurrentSample*K_SAMPLE_STEP_SIZE
		local GuessForT = IntervalStart + K_SAMPLE_STEP_SIZE*(t - SampleValues[CurrentSample]) / (SampleValues[CurrentSample + 1] - SampleValues[CurrentSample])
		local InitialSlope = (i*GuessForT + j)*GuessForT + e

		if InitialSlope >= NEWTON_MIN_SLOPE then
			for NewtonRaphsonIterate = 1, NEWTON_ITERATIONS do
				local CurrentSlope = (i*GuessForT + j)*GuessForT + e
				if CurrentSlope == 0 then break end
				GuessForT = GuessForT - (((g*GuessForT + h)*GuessForT + e)*GuessForT - t) / CurrentSlope
			end
		elseif InitialSlope ~= 0 then
			local IntervalStep = IntervalStart + K_SAMPLE_STEP_SIZE

			for BinarySubdivide = 1, SUBDIVISION_MAX_ITERATIONS do
				GuessForT = IntervalStart + 0.5*(IntervalStep - IntervalStart)
				local BezierCalculation = ((g*GuessForT + h)*GuessForT + e)*GuessForT - t

				if BezierCalculation > 0 then
					IntervalStep = GuessForT
				else
					IntervalStart = GuessForT
					BezierCalculation = -BezierCalculation
				end

				if BezierCalculation <= SUBDIVISION_PRECISION then break end
			end
		end

		return ((l*GuessForT + m)*GuessForT + k)*GuessForT
	end
end

return Bezier]]></ProtectedString>
						<BinaryString name="Tags"></BinaryString>
					</Properties>
				</Item>
				<Item class="ModuleScript" referent="RBX4CD28364505B4FD7A9FA391F48ADB151">
					<Properties>
						<Content name="LinkedSource"><null></null></Content>
						<string name="Name">easing-functions</string>
						<string name="ScriptGuid">{B1A90586-227B-4CD5-8696-D24A5E4EDF6A}</string>
						<ProtectedString name="Source"><![CDATA[-- Prescribed Material design Beziers and optimized Robert Penner functions
-- @author Robert Penner

local Bezier = require(assert(script.Parent:FindFirstChild("cubic-bezier"), "[@rbxts/easing-functions] Please `npm install @rbxts/cubic-bezier` to use this library."))

-- @specs https://material.io/design/motion/speed.html#easing
local Sharp = Bezier.new(0.4, 0, 0.6, 1)
local Standard = Bezier.new(0.4, 0, 0.2, 1)
local Acceleration = Bezier.new(0.4, 0, 1, 1)
local Deceleration = Bezier.new(0, 0, 0.2, 1)

--[[
	Disclaimer for Robert Penner's Easing Equations license:

	TERMS OF USE - EASING EQUATIONS

	Open source under the BSD License.

	Copyright  2001 Robert Penner
	All rights reserved.

	Redistribution and use in source and binary forms, with or without modification, are permitted provided that the following conditions are met:

	* Redistributions of source code must retain the above copyright notice, this list of conditions and the following disclaimer.
	* Redistributions in binary form must reproduce the above copyright notice, this list of conditions and the following disclaimer in the documentation and/or other materials provided with the distribution.
	* Neither the name of the author nor the names of contributors may be used to endorse or promote products derived from this software without specific prior written permission.

	THIS SOFTWARE IS PROVIDED BY THE COPYRIGHT HOLDERS AND CONTRIBUTORS "AS IS" AND ANY EXPRESS OR IMPLIED WARRANTIES, INCLUDING, BUT NOT LIMITED TO, THE IMPLIED WARRANTIES OF MERCHANTABILITY AND FITNESS FOR A PARTICULAR PURPOSE ARE DISCLAIMED.
	IN NO EVENT SHALL THE COPYRIGHT OWNER OR CONTRIBUTORS BE LIABLE FOR ANY DIRECT, INDIRECT, INCIDENTAL, SPECIAL, EXEMPLARY, OR CONSEQUENTIAL DAMAGES (INCLUDING, BUT NOT LIMITED TO, PROCUREMENT OF SUBSTITUTE GOODS OR SERVICES; LOSS OF USE, DATA, OR PROFITS;
	OR BUSINESS INTERRUPTION) HOWEVER CAUSED AND ON ANY THEORY OF LIABILITY, WHETHER IN CONTRACT, STRICT LIABILITY, OR TORT (INCLUDING NEGLIGENCE OR OTHERWISE) ARISING IN ANY WAY OUT OF THE USE OF THIS SOFTWARE, EVEN IF ADVISED OF THE POSSIBILITY OF SUCH DAMAGE.
]]

-- For all easing functions:
-- t = elapsed time
-- b = beginning value
-- c = change in value same as: ending - beginning
-- d = duration (total time)

-- Where applicable
-- a = amplitude
-- p = period

local sin = math.sin
local cos = math.cos
local abs = math.abs
local asin = math.asin
local exp = math.exp

local SoftSpringpi = -3.2*3.1415926535897932
local Springpi = 2*SoftSpringpi

local function Linear(t, b, c, d)
	return c * t / d + b
end

local function Smooth(t, b, c, d)
	t = t / d
	return c * t * t * (3 - 2*t) + b
end

local function Smoother(t, b, c, d)
	t = t / d
	return c*t*t*t * (t * (6*t - 15) + 10) + b
end

-- Arceusinator's Easing Functions
local function RevBack(t, b, c, d)
	t = 1 - t / d
	return c*(1 - (sin(t*1.5707963267948966) + (sin(t*3.1415926535897932) * (cos(t*3.1415926535897932) + 1)*0.5))) + b
end

local function RidiculousWiggle(t, b, c, d)
	t = t / d
	return c*sin(sin(t*3.1415926535897932)*1.5707963267948966) + b
end

-- YellowTide's Easing Functions
local function Spring(t, b, c, d)
	t = t / d
	return (1 + (-exp(-6.9 * t) * cos(Springpi*t))) * c + b
end

local function SoftSpring(t, b, c, d)
	t = t / d
	return (1 + (-exp(-7.5 * t) * cos(SoftSpringpi*t))) * c + b
end
-- End of YellowTide's functions

local function InQuad(t, b, c, d)
	t = t / d
	return c * t * t + b
end

local function OutQuad(t, b, c, d)
	t = t / d
	return -c * t * (t - 2) + b
end

local function InOutQuad(t, b, c, d)
	t = t / d * 2

	if t < 1 then
		return c * 0.5 * t * t + b
	else
		return -c * 0.5 * ((t - 1) * (t - 3) - 1) + b
	end
end

local function OutInQuad(t, b, c, d)
	if t < d * 0.5 then
		t = 2 * t / d
		return -0.5 * c * t * (t - 2) + b
	else
		t = ((t * 2) - d) / d
		c = 0.5 * c
		return c * t * t + b + c
	end
end

local function InCubic(t, b, c, d)
	t = t / d
	return c * t * t * t + b
end

local function OutCubic(t, b, c, d)
	t = t / d - 1
	return c * (t * t * t + 1) + b
end

local function InOutCubic(t, b, c, d)
	t = t / d * 2
	if t < 1 then
		return c * 0.5 * t * t * t + b
	else
		t = t - 2
		return c * 0.5 * (t * t * t + 2) + b
	end
end

local function OutInCubic(t, b, c, d)
	if t < d * 0.5 then
		t = t * 2 / d - 1
		return c * 0.5 * (t * t * t + 1) + b
	else
		t = ((t * 2) - d) / d
		c = c * 0.5
		return c * t * t * t + b + c
	end
end

local function InQuart(t, b, c, d)
	t = t / d
	return c * t * t * t * t + b
end

local function OutQuart(t, b, c, d)
	t = t / d - 1
	return -c * (t * t * t * t - 1) + b
end

local function InOutQuart(t, b, c, d)
	t = t / d * 2
	if t < 1 then
		return c * 0.5 * t * t * t * t + b
	else
		t = t - 2
		return -c * 0.5 * (t * t * t * t - 2) + b
	end
end

local function OutInQuart(t, b, c, d)
	if t < d * 0.5 then
		t = t * 2 / d - 1
		c = c * 0.5
		return -c * (t * t * t * t - 1) + b
	else
		t = ((t * 2) - d) / d
		c = c * 0.5
		return c * t * t * t * t + b + c
	end
end

local function InQuint(t, b, c, d)
	t = t / d
	return c * t * t * t * t * t + b
end

local function OutQuint(t, b, c, d)
	t = t / d - 1
	return c * (t * t * t * t * t + 1) + b
end

local function InOutQuint(t, b, c, d)
	t = t / d * 2
	if t < 1 then
		return c * 0.5 * t * t * t * t * t + b
	else
		t = t - 2
		return c * 0.5 * (t * t * t * t * t + 2) + b
	end
end

local function OutInQuint(t, b, c, d)
	if t < d * 0.5 then
		t = t * 2 / d - 1
		return c * 0.5 * (t * t * t * t * t + 1) + b
	else
		t = ((t * 2) - d) / d
		c = c * 0.5
		return c * t * t * t * t * t + b + c
	end
end

local function InSine(t, b, c, d)
	return -c * cos(t / d * 1.5707963267948966) + c + b
end

local function OutSine(t, b, c, d)
	return c * sin(t / d * 1.5707963267948966) + b
end

local function InOutSine(t, b, c, d)
	return -c * 0.5 * (cos(3.1415926535897932 * t / d) - 1) + b
end

local function OutInSine(t, b, c, d)
	c = c * 0.5
	if t < d * 0.5 then
		return c * sin(t * 2 / d * 1.5707963267948966) + b
	else
		return -c * cos(((t * 2) - d) / d * 1.5707963267948966) + 2 * c + b
	end
end

local function InExpo(t, b, c, d)
	if t == 0 then
		return b
	else
		return c * 1024 ^ (t / d - 1) + b - c * 0.001
	end
end

local function OutExpo(t, b, c, d)
	if t == d then
		return b + c
	else
		return c * 1.001 * (1 - exp(-6.9314718055994531 * (t / d))) + b
	end
end

local function InOutExpo(t, b, c, d)
	t = t / d * 2

	if t == 0 then
		return b
	elseif t == 2 then
		return b + c
	elseif t < 1 then
		return c * 0.5 * 1024 ^ (t - 1) + b - c * 0.0005
	else
		return c * 0.50025 * (2 - exp(-6.9314718055994531 * (t - 1))) + b
	end
end

local function OutInExpo(t, b, c, d)
	c = c * 0.5
	if t < d * 0.5 then
		if t * 2 == d then
			return b + c
		else
			return c * 1.001 * (1 - exp(13.8629436111989062 * t / d)) + b
		end
	else
		if t * 2 - d == 0 then
			return b + c
		else
			return c * 1024 ^ ((t * 2 - d) / d - 1) + b + c - c * 0.001
		end
	end
end

local function InCirc(t, b, c, d)
	t = t / d
	return -c * ((1 - t * t) ^ 0.5 - 1) + b
end

local function OutCirc(t, b, c, d)
	t = t / d - 1
	return c * (1 - t * t) ^ 0.5 + b
end

local function InOutCirc(t, b, c, d)
	t = t / d * 2
	if t < 1 then
		return -c * 0.5 * ((1 - t * t) ^ 0.5 - 1) + b
	else
		t = t - 2
		return c * 0.5 * ((1 - t * t) ^ 0.5 + 1) + b
	end
end

local function OutInCirc(t, b, c, d)
	c = c * 0.5
	if t < d * 0.5 then
		t = t * 2 / d - 1
		return c * (1 - t * t) ^ 0.5 + b
	else
		t = (t * 2 - d) / d
		return -c * ((1 - t * t) ^ 0.5 - 1) + b + c
	end
end

local function InElastic(t, b, c, d, a, p)
	t = t / d - 1
	if t == -1 then
		return b
	else
		if t == 0 then
			return b + c
		else
			p = p or d * 0.3
			local abs_c

			if c < 0 then
				abs_c = -c
			else
				abs_c = c
			end

			if a == nil or a < abs_c then
				return -(c * 1024 ^ t * sin((t * d - p * 0.25) * 6.2831853071795864 / p)) + b
			else
				return -(a * 1024 ^ t * sin((t * d - p / 6.2831853071795864 * asin(c/a)) * 6.2831853071795864 / p)) + b
			end
		end
	end
end

local function OutElastic(t, b, c, d, a, p)
	t = t / d
	if t == 0 then
		return b
	else
		if t == 1 then
			return b + c
		else
			p = p or d * 0.3
			local abs_c

			if c < 0 then
				abs_c = -c
			else
				abs_c = c
			end

			if a == nil or a < abs_c then
				return c * exp(-6.9314718055994531 * t) * sin((t * d - p * 0.25) * 6.2831853071795864 / p) + c + b
			else
				return a * exp(-6.9314718055994531 * t) * sin((t * d - p / 6.2831853071795864 * asin(c / a)) * 6.2831853071795864 / p) + c + b
			end
		end
	end
end

local function InOutElastic(t, b, c, d, a, p)
	if t == 0 then
		return b
	end

	t = t / d * 2 - 1

	if t == 1 then
		return b + c
	end

	p = p or d * 0.45
	a = a or 0

	local s
	local abs_c

	if c < 0 then
		abs_c = -c
	else
		abs_c = c
	end

	if a == nil or a < abs_c then
		a = c
		s = p * 0.25
	else
		s = p / 6.2831853071795864 * asin(c / a)
	end

	if t < 1 then
		return -0.5 * a * 1024 ^ t * sin((t * d - s) * 6.2831853071795864 / p) + b
	else
		return a * exp(-6.9314718055994531 * t) * sin((t * d - s) * 6.2831853071795864 / p ) * 0.5 + c + b
	end
end

local function OutInElastic(t, b, c, d, a, p)
	if t < d * 0.5 then
		return OutElastic(t * 2, b, c * 0.5, d, a, p)
	else
		return InElastic(t * 2 - d, b + c * 0.5, c * 0.5, d, a, p)
	end
end

local function InBack(t, b, c, d, s)
	s = s or 1.70158
	t = t / d
	return c * t * t * ((s + 1) * t - s) + b
end

local function OutBack(t, b, c, d, s)
	s = s or 1.70158
	t = t / d - 1
	return c * (t * t * ((s + 1) * t + s) + 1) + b
end

local function InOutBack(t, b, c, d, s)
	s = (s or 1.70158) * 1.525
	t = t / d * 2
	if t < 1 then
		return c * 0.5 * (t * t * ((s + 1) * t - s)) + b
	else
		t = t - 2
		return c * 0.5 * (t * t * ((s + 1) * t + s) + 2) + b
	end
end

local function OutInBack(t, b, c, d, s)
	c = c * 0.5
	s = s or 1.70158
	if t < d * 0.5 then
		t = (t * 2) / d - 1
		return c * (t * t * ((s + 1) * t + s) + 1) + b
	else
		t = ((t * 2) - d) / d
		return c * t * t * ((s + 1) * t - s) + b + c
	end
end

local function OutBounce(t, b, c, d)
	t = t / d
	if t < 1 / 2.75 then
		return c * (7.5625 * t * t) + b
	elseif t < 2 / 2.75 then
		t = t - (1.5 / 2.75)
		return c * (7.5625 * t * t + 0.75) + b
	elseif t < 2.5 / 2.75 then
		t = t - (2.25 / 2.75)
		return c * (7.5625 * t * t + 0.9375) + b
	else
		t = t - (2.625 / 2.75)
		return c * (7.5625 * t * t + 0.984375) + b
	end
end

local function InBounce(t, b, c, d)
	return c - OutBounce(d - t, 0, c, d) + b
end

local function InOutBounce(t, b, c, d)
	if t < d * 0.5 then
		return InBounce(t * 2, 0, c, d) * 0.5 + b
	else
		return OutBounce(t * 2 - d, 0, c, d) * 0.5 + c * 0.5 + b
	end
end

local function OutInBounce(t, b, c, d)
	if t < d * 0.5 then
		return OutBounce(t * 2, b, c * 0.5, d)
	else
		return InBounce(t * 2 - d, b + c * 0.5, c * 0.5, d)
	end
end

return {
	Standard = Standard;
	Deceleration = Deceleration;
	Acceleration = Acceleration;
	Sharp = Sharp;

	Linear = Linear;

	InSine = InSine;
	OutSine = OutSine;
	InOutSine = InOutSine;
	OutInSine = OutInSine;

	InBack = InBack;
	OutBack = OutBack;
	InOutBack = InOutBack;
	OutInBack = OutInBack;

	InQuad = InQuad;
	OutQuad = OutQuad;
	InOutQuad = InOutQuad;
	OutInQuad = OutInQuad;

	InQuart = InQuart;
	OutQuart = OutQuart;
	InOutQuart = InOutQuart;
	OutInQuart = OutInQuart;

	InQuint = InQuint;
	OutQuint = OutQuint;
	InOutQuint = InOutQuint;
	OutInQuint = OutInQuint;

	InBounce = InBounce;
	OutBounce = OutBounce;
	InOutBounce = InOutBounce;
	OutInBounce = OutInBounce;

	InElastic = InElastic;
	OutElastic = OutElastic;
	InOutElastic = InOutElastic;
	OutInElastic = OutInElastic;

	InCirc = InCirc;
	OutCirc = OutCirc;
	InOutCirc = InOutCirc;
	OutInCirc = OutInCirc;

	InCubic = InCubic;
	OutCubic = OutCubic;
	InOutCubic = InOutCubic;
	OutInCubic = OutInCubic;

	InExpo = InExpo;
	OutExpo = OutExpo;
	InOutExpo = InOutExpo;
	OutInExpo = OutInExpo;

	Smooth = Smooth;
	Smoother = Smoother;
	RevBack = RevBack;
	RidiculousWiggle = RidiculousWiggle;
	Spring = Spring;
	SoftSpring = SoftSpring;
}
]]></ProtectedString>
						<BinaryString name="Tags"></BinaryString>
					</Properties>
				</Item>
				<Item class="ModuleScript" referent="RBXD02BA9FEAF03477F967831B2527C6821">
					<Properties>
						<Content name="LinkedSource"><null></null></Content>
						<string name="Name">lerp-functions</string>
						<string name="ScriptGuid">{5EE5B04A-9C72-4C3D-B1CC-E89A90C85B9F}</string>
						<ProtectedString name="Source"><![CDATA[local function sortByTime(a, b)
	return a.Time < b.Time
end

-- Mostly ripped off from https://github.com/Fraktality/anim/blob/master/anim.lua
local Lerps = {}

-- bool
function Lerps.boolean(v0, v1)
	return function(t)
		if t < 0.5 then
			return v0
		else
			return v1
		end
	end
end

-- number
function Lerps.number(v0, v1)
	local dv = v1 - v0
	return function(t)
		return v0 + dv*t
	end
end

do -- Color3
	local C3 = Color3.new
	local black = C3(0, 0, 0)

	function Lerps.Color3(c0, c1)
		local u0, v0, u1, v1, l0, l1

		-- Convert from linear RGB to scaled CIELUV (RgbToLuv13)
		local r, g, b = c0.r, c0.g, c0.b
		-- Apply inverse gamma correction

		if r < 0.0404482362771076 then
			r = r / 12.92
		else
			r = 0.87941546140213*(r + 0.055)^2.4
		end

		if g < 0.0404482362771076 then
			g = g / 12.92
		else
			g = 0.87941546140213*(g + 0.055)^2.4
		end

		if b < 0.0404482362771076 then
			b = b / 12.92
		else
			b = 0.87941546140213*(b + 0.055)^2.4
		end

		-- sRGB->XYZ->CIELUV
		local y = 0.2125862307855956*r + 0.71517030370341085*g + 0.0722004986433362*b
		local z = 3.6590806972265883*r + 11.4426895800574232*g + 4.1149915024264843*b

		if y > 0.008856451679035631 then
			l0 = 116*y^(1/3) - 16
		else
			l0 = 903.296296296296*y
		end

		if z > 1e-15 then
			u0, v0 = l0*(0.9257063972951867*r - 0.8333736323779866*g - 0.09209820666085898*b)/z, l0*(9*y/z - 0.46832)
		else
			u0, v0 = -0.19783*l0, -0.46832*l0
		end

		-- Convert from linear RGB to scaled CIELUV (RgbToLuv13)
		r, g, b = c1.r, c1.g, c1.b
		-- Apply inverse gamma correction

		if r < 0.0404482362771076 then
			r = r / 12.92
		else
			r = 0.87941546140213*(r + 0.055)^2.4
		end

		if g < 0.0404482362771076 then
			g = g / 12.92
		else
			g = 0.87941546140213*(g + 0.055)^2.4
		end

		if b < 0.0404482362771076 then
			b = b / 12.92
		else
			b = 0.87941546140213*(b + 0.055)^2.4
		end

		-- sRGB->XYZ->CIELUV
		y = 0.2125862307855956*r + 0.71517030370341085*g + 0.0722004986433362*b
		z = 3.6590806972265883*r + 11.4426895800574232*g + 4.1149915024264843*b

		if y > 0.008856451679035631 then
			l1 = 116*y^(1/3) - 16
		else
			l1 = 903.296296296296*y
		end

		if z > 1e-15 then
			u1, v1 = l1*(0.9257063972951867*r - 0.8333736323779866*g - 0.09209820666085898*b)/z, l1*(9*y/z - 0.46832)
		else
			u1, v1 = -0.19783*l1, -0.46832*l1
		end

		return function(t)
			local l = (1 - t)*l0 + t*l1
			if l < 0.0197955 then
				return black
			end

			local u = ((1 - t)*u0 + t*u1)/l + 0.19783
			local v = ((1 - t)*v0 + t*v1)/l + 0.46832

			local y = (l + 16)/116

			if y > 0.206896551724137931 then
				y = y*y*y
			else
				y = 0.12841854934601665*y - 0.01771290335807126
			end

			local x = y*u/v
			local z = y*((3 - 0.75*u)/v - 5)

			local r =  7.2914074*x - 1.5372080*y - 0.4986286*z
			local g = -2.1800940*x + 1.8757561*y + 0.0415175*z
			local b =  0.1253477*x - 0.2040211*y + 1.0569959*z

			if r < 0 and r < g and r < b then
				r, g, b = 0, g - r, b - r
			elseif g < 0 and g < b then
				r, g, b = r - g, 0, b - g
			elseif b < 0 then
				r, g, b = r - b, g - b, 0
			end

			if r < 3.1306684425e-3 then
				r = 12.92*r
			else
				r = 1.055*r^(1 / 2.4) - 0.055
			end

			if g < 3.1306684425e-3 then
				g = 12.92*g
			else
				g = 1.055*g^(1 / 2.4) - 0.055
			end

			if b < 3.1306684425e-3 then
				b = 12.92*b
			else
				b = 1.055*b^(1 / 2.4) - 0.055
			end

			if r < 0 then
				r = 0
			elseif r > 1 then
				r = 1
			end

			if g < 0 then
				g = 0
			elseif g > 1 then
				g = 1
			end

			if b < 0 then
				b = 0
			elseif b > 1 then
				b = 1
			end

			return C3(r, g, b)
		end
	end
end

do -- string
	local s_match = string.match
	local s_format = string.format
	local atof = tonumber

	function Lerps.string(v0, v1)
		local n0, d do
			local sign0, h0, m0, s0 = s_match(v0, '^([+-]?)(%d*):[+-]?(%d*):[+-]?(%d*)$')
			local sign1, h1, m1, s1 = s_match(v1, '^([+-]?)(%d*):[+-]?(%d*):[+-]?(%d*)$')
			if sign0 and sign1 then
				n0       = 3600*(atof(h0) or 0) + 60*(atof(m0) or 0) + (atof(s0) or 0)
				local n1 = 3600*(atof(h1) or 0) + 60*(atof(m1) or 0) + (atof(s1) or 0)
				if sign0 == '-' then
					n0 = -n0
				end
				d = (43200 + (sign1 ~= '-' and n1 or -n1) - n0)%86400 - 43200
			else
				error('Invalid TimeOfDay string', 4)
			end
		end

		return function(t)
			local fs = (n0 + d*t)%86400
			local s = fs > 0 and fs or -fs
			return s_format(
				fs < 0 and '-%.2u:%.2u:%.2u' or '%.2u:%.2u:%.2u',
				(s - s%3600)/3600,
				(s%3600 - s%60)/60,
				s%60
			)
		end
	end
end

do -- CFrame
	local Slerp = CFrame.new().lerp
	function Lerps.CFrame(v0, v1)
		return function(t)
			return Slerp(v0, v1, t)
		end
	end
end

do -- NumberRange
	local NR = NumberRange.new
	function Lerps.NumberRange(v0, v1)
		local min0, max0 = v0.Min, v0.Max
		local dmin, dmax = v1.Min - min0, v1.Max - max0
		v0, v1 = nil, nil
		return function(t)
			return NR(min0 + t*dmin, max0 + t*dmax)
		end
	end
end

do -- NumberSequenceKeypoint
	local NSK = NumberSequenceKeypoint.new
	function Lerps.NumberSequenceKeypoint(v0, v1)
		local t0, v0, e0 = v0.Time, v0.Value, v0.Envelope
		local dt, dv, de = v1.Time - t0, v1.Value - v0, v1.Envelope - e0
		v1 = nil
		return function(t)
			return NSK(t0 + t*dt, v0 + t*dv, e0 + t*de)
		end
	end
end

do -- PhysicalProperties
	local PP = PhysicalProperties.new
	function Lerps.PhysicalProperties(v0, v1)
		local d0, e0, ew0, f0, fw0 =
			v0.Density,
			v0.Elasticity,
			v0.ElasticityWeight,
			v0.Friction,
			v0.FrictionWeight
		local dd, de, dew, df, dfw =
			v1.Density - d0,
			v1.Elasticity - e0,
			v1.ElasticityWeight - ew0,
			v1.Friction - f0,
			v1.FrictionWeight - fw0
		v0, v1 = nil, nil
		return function(t)
			return PP(d0 + t*dd, e0 + t*de, ew0 + t*dew, f0 + t*df, fw0 + t*dfw)
		end
	end
end

do -- Ray
	local R = Ray.new
	local V3 = Vector3.new
	function Lerps.Ray(v0, v1)
		local o0, d0, o1, d1 =
			v0.Origin, v0.Direction,
			v1.Origin, v1.Direction
		local ox0, oy0, oz0, dx0, dy0, dz0, dx1, dy1, dz1 =
			o0.x, o0.y, o0.z,
			d0.x, d0.y, d0.z,
			d1.x, d1.y, d1.z
		local dox, doy, doz, ddx, ddy, ddz =
			o1.x - ox0, o1.y - oy0, o1.z - oz0,
			d1.x - dx0, d1.y - dy0, d1.z - dz0
		v0, v1, o0, d0, o1, d1 = nil, nil, nil, nil, nil, nil
		return function(t)
			return R(
				V3(ox0 + t*dox, oy0 + t*doy, oz0 + t*doz),
				V3(dx0 + t*ddx, dy0 + t*ddy, dz0 + t*ddz)
			)
		end
	end
end

do
	newRect = Rect.new

	function Lerps.Rect(v0, v1)
		local sc, of = v0.Min.X, v0.Min.Y
		local dsc, dof = v1.Min.X - sc, v1.Min.Y - of
		local sc2, of2 = v0.Max.X, v0.Max.Y
		local dsc2, dof2 = v1.Max.X - sc2, v1.Max.Y - of2
		v0, v1 = nil, nil

		return function(t)
			return newRect(
				sc + t*dsc, of + t*dof,
				sc2 + t*dsc2, of2 + t*dof2
			)
		end
	end
end

do -- UDim
	local UD = UDim.new
	function Lerps.UDim(v0, v1)
		local sc, of = v0.Scale, v0.Offset
		local dsc, dof = v1.Scale - sc, v1.Offset - of
		v0, v1 = nil, nil
		return function(t)
			return UD(sc + t*dsc, of + t*dof)
		end
	end
end

do -- UDim2
	local Lerp = UDim2.new().Lerp
	function Lerps.UDim2(v0, v1)
		return function(t)
			return Lerp(v0, v1, t)
		end
	end
end

do -- Vector2
	local V2 = Vector2.new
	function Lerps.Vector2(v0, v1)
		local x, y = v0.x, v0.y
		local dx, dy = v1.x - x, v1.y - y
		v0, v1 = nil, nil
		return function(t)
			return V2(x + t*dx, y + t*dy)
		end
	end
end

do -- Vector3
	local V3 = Vector3.new
	function Lerps.Vector3(v0, v1)
		local x, y, z = v0.x, v0.y, v0.z
		local dx, dy, dz = v1.x - x, v1.y - y, v1.z - z
		v0, v1 = nil, nil
		return function(t)
			return V3(x + t*dx, y + t*dy, z + t*dz)
		end
	end
end

do -- ColorSequence
	local newColorSequence = ColorSequence.new
	local Color3Lerp = Lerps.Color3

	function Lerps.ColorSequence(start, finish)
		local l1 = Color3Lerp(start[1], finish[1])
		local l2 = Color3Lerp(start[2], finish[2])

		return function(alpha)
			return newColorSequence(l1(alpha), l2(alpha))
		end
	end
end

do -- Region3
	local newRegion3 = Region3.new
	local newVector3 = Vector3.new

	function Lerps.Region3(start, finish) -- @author Sharksie
		local start1 = start.CFrame * (-start.Size*0.5)
		local start2 = start.CFrame * ( start.Size*0.5)

		local finish1 = finish.CFrame * (-finish.Size*0.5)
		local finish2 = finish.CFrame * ( finish.Size*0.5)

		local change1 = finish1 - start1
		local change2 = finish2 - start2

		return function(alpha)
			local imin = start1 + alpha * change1
			local imax = start2 + alpha * change2

			local iminx = imin.x
			local imaxx = imax.x

			local iminy = imin.y
			local imaxy = imax.y

			local iminz = imin.z
			local imaxz = imax.z

			local x1, x2
			local y1, y2
			local z1, z2

			if iminx < imaxx then
				x1 = iminx
				x2 = imaxx
			else
				x1 = imaxx
				x2 = iminx
			end

			if iminy < imaxy then
				y1 = iminy
				y2 = imaxy
			else
				y1 = imaxy
				y2 = iminy
			end

			if iminz < imaxz then
				z1 = iminz
				z2 = imaxz
			else
				z1 = imaxz
				z2 = iminz
			end

			return newRegion3(
				newVector3(x1, y1, z1),
				newVector3(x2, y2, z2)
			)
		end
	end;
end

do
	function Lerps.NumberSequence(start, finish)
		return function(alpha)
			-- @author Sharksie

			-- For each point on each line, find the values of the other sequence at that point in time through interpolation
			-- 	then interpolate between the known value and the learned value
			-- 	then use that value to create a new keypoint at the time
			-- 	then build a new sequence using all the keypoints generated

			local keypoints = {}
			local addedTimes = {}

			for i, ap in next, start.Keypoints do
				local closestAbove, closestBelow

				for i, bp in next, finish.Keypoints do
					if bp.Time == ap.Time then
						closestAbove, closestBelow = bp, bp
						break
					elseif bp.Time < ap.Time and (closestBelow == nil or bp.Time > closestBelow.Time) then
						closestBelow = bp
					elseif bp.Time > ap.Time and (closestAbove == nil or bp.Time < closestAbove.Time) then
						closestAbove = bp
					end
				end

				local bValue, bEnvelope
				if closestAbove == closestBelow then
					bValue, bEnvelope = closestAbove.Value, closestAbove.Envelope
				else
					local p = (ap.Time - closestBelow.Time)/(closestAbove.Time - closestBelow.Time)
					bValue = (closestAbove.Value - closestBelow.Value)*p + closestBelow.Value
					bEnvelope = (closestAbove.Envelope - closestBelow.Envelope)*p + closestBelow.Envelope
				end
				local interValue = (bValue - ap.Value)*alpha + ap.Value
				local interEnvelope = (bEnvelope - ap.Envelope)*alpha + ap.Envelope
				local interp = NumberSequenceKeypoint.new(ap.Time, interValue, interEnvelope)

				table.insert(keypoints, interp)

				addedTimes[ap.Time] = true
			end

			for i, bp in next, finish.Keypoints do
				if not addedTimes[bp.Time] then
					local closestAbove, closestBelow

					for i, ap in next, start.Keypoints do
						if ap.Time == bp.Time then
							closestAbove, closestBelow = ap, ap
							break
						elseif ap.Time < bp.Time and (closestBelow == nil or ap.Time > closestBelow.Time) then
							closestBelow = ap
						elseif ap.Time > bp.Time and (closestAbove == nil or ap.Time < closestAbove.Time) then
							closestAbove = ap
						end
					end

					local aValue, aEnvelope
					if closestAbove == closestBelow then
						aValue, aEnvelope = closestAbove.Value, closestAbove.Envelope
					else
						local p = (bp.Time - closestBelow.Time)/(closestAbove.Time - closestBelow.Time)
						aValue = (closestAbove.Value - closestBelow.Value)*p + closestBelow.Value
						aEnvelope = (closestAbove.Envelope - closestBelow.Envelope)*p + closestBelow.Envelope
					end
					local interValue = (bp.Value - aValue)*alpha + aValue
					local interEnvelope = (bp.Envelope - aEnvelope)*alpha + aEnvelope
					local interp = NumberSequenceKeypoint.new(bp.Time, interValue, interEnvelope)

					table.insert(keypoints, interp)
				end
			end

			table.sort(keypoints, sortByTime)

			return NumberSequence.new(keypoints)
		end
	end
end

return Lerps
]]></ProtectedString>
						<BinaryString name="Tags"></BinaryString>
					</Properties>
				</Item>
				<Item class="Folder" referent="RBX8078B55B5B8B489F82D853763E9253EC">
					<Properties>
						<string name="Name">roact</string>
						<BinaryString name="Tags"></BinaryString>
					</Properties>
					<Item class="Folder" referent="RBXFC953436190545AE9A9FD5408DCE1DAF">
						<Properties>
							<string name="Name">roact</string>
							<BinaryString name="Tags"></BinaryString>
						</Properties>
						<Item class="ModuleScript" referent="RBXA6DF93045CE94BFB9561B153B1882A80">
							<Properties>
								<Content name="LinkedSource"><null></null></Content>
								<string name="Name">src</string>
								<string name="ScriptGuid">{2A42AD3D-40CB-4BE1-B77B-831E78EF933E}</string>
								<ProtectedString name="Source"><![CDATA[--[[
	Packages up the internals of Roact and exposes a public API for it.
]]

local GlobalConfig = require(script.GlobalConfig)
local createReconciler = require(script.createReconciler)
local createReconcilerCompat = require(script.createReconcilerCompat)
local RobloxRenderer = require(script.RobloxRenderer)
local strict = require(script.strict)
local Binding = require(script.Binding)

local robloxReconciler = createReconciler(RobloxRenderer)
local reconcilerCompat = createReconcilerCompat(robloxReconciler)

local Roact = strict {
	Component = require(script.Component),
	createElement = require(script.createElement),
	createFragment = require(script.createFragment),
	oneChild = require(script.oneChild),
	PureComponent = require(script.PureComponent),
	None = require(script.None),
	Portal = require(script.Portal),
	createRef = require(script.createRef),
	createBinding = Binding.create,
	joinBindings = Binding.join,

	Change = require(script.PropMarkers.Change),
	Children = require(script.PropMarkers.Children),
	Event = require(script.PropMarkers.Event),
	Ref = require(script.PropMarkers.Ref),

	mount = robloxReconciler.mountVirtualTree,
	unmount = robloxReconciler.unmountVirtualTree,
	update = robloxReconciler.updateVirtualTree,

	reify = reconcilerCompat.reify,
	teardown = reconcilerCompat.teardown,
	reconcile = reconcilerCompat.reconcile,

	setGlobalConfig = GlobalConfig.set,

	-- APIs that may change in the future without warning
	UNSTABLE = {
	},
}

return Roact]]></ProtectedString>
								<BinaryString name="Tags"></BinaryString>
							</Properties>
							<Item class="ModuleScript" referent="RBXEB472B9901CC4F9981524E59A76419CF">
								<Properties>
									<Content name="LinkedSource"><null></null></Content>
									<string name="Name">Binding</string>
									<string name="ScriptGuid">{BF82FDB3-E657-437C-9FAC-5A806B59C8EC}</string>
									<ProtectedString name="Source"><![CDATA[local createSignal = require(script.Parent.createSignal)
local Symbol = require(script.Parent.Symbol)
local Type = require(script.Parent.Type)

local config = require(script.Parent.GlobalConfig).get()

local BindingImpl = Symbol.named("BindingImpl")

local BindingInternalApi = {}

local bindingPrototype = {}

function bindingPrototype:getValue()
	return BindingInternalApi.getValue(self)
end

function bindingPrototype:map(predicate)
	return BindingInternalApi.map(self, predicate)
end

local BindingPublicMeta = {
	__index = bindingPrototype,
	__tostring = function(self)
		return string.format("RoactBinding(%s)", tostring(self:getValue()))
	end,
}

function BindingInternalApi.update(binding, newValue)
	return binding[BindingImpl].update(newValue)
end

function BindingInternalApi.subscribe(binding, callback)
	return binding[BindingImpl].subscribe(callback)
end

function BindingInternalApi.getValue(binding)
	return binding[BindingImpl].getValue()
end

function BindingInternalApi.create(initialValue)
	local impl = {
		value = initialValue,
		changeSignal = createSignal(),
	}

	function impl.subscribe(callback)
		return impl.changeSignal:subscribe(callback)
	end

	function impl.update(newValue)
		impl.value = newValue
		impl.changeSignal:fire(newValue)
	end

	function impl.getValue()
		return impl.value
	end

	return setmetatable({
		[Type] = Type.Binding,
		[BindingImpl] = impl,
	}, BindingPublicMeta), impl.update
end

function BindingInternalApi.map(upstreamBinding, predicate)
	if config.typeChecks then
		assert(Type.of(upstreamBinding) == Type.Binding, "Expected arg #1 to be a binding")
		assert(typeof(predicate) == "function", "Expected arg #1 to be a function")
	end

	local impl = {}

	function impl.subscribe(callback)
		return BindingInternalApi.subscribe(upstreamBinding, function(newValue)
			callback(predicate(newValue))
		end)
	end

	function impl.update(newValue)
		error("Bindings created by Binding:map(fn) cannot be updated directly", 2)
	end

	function impl.getValue()
		return predicate(upstreamBinding:getValue())
	end

	return setmetatable({
		[Type] = Type.Binding,
		[BindingImpl] = impl,
	}, BindingPublicMeta)
end

function BindingInternalApi.join(upstreamBindings)
	if config.typeChecks then
		assert(typeof(upstreamBindings) == "table", "Expected arg #1 to be of type table")

		for key, value in pairs(upstreamBindings) do
			if Type.of(value) ~= Type.Binding then
				local message = (
					"Expected arg #1 to contain only bindings, but key %q had a non-binding value"
				):format(
					tostring(key)
				)
				error(message, 2)
			end
		end
	end

	local impl = {}

	local function getValue()
		local value = {}

		for key, upstream in pairs(upstreamBindings) do
			value[key] = upstream:getValue()
		end

		return value
	end

	function impl.subscribe(callback)
		local disconnects = {}

		for key, upstream in pairs(upstreamBindings) do
			disconnects[key] = BindingInternalApi.subscribe(upstream, function(newValue)
				callback(getValue())
			end)
		end

		return function()
			if disconnects == nil then
				return
			end

			for _, disconnect in pairs(disconnects) do
				disconnect()
			end

			disconnects = nil
		end
	end

	function impl.update(newValue)
		error("Bindings created by joinBindings(...) cannot be updated directly", 2)
	end

	function impl.getValue()
		return getValue()
	end

	return setmetatable({
		[Type] = Type.Binding,
		[BindingImpl] = impl,
	}, BindingPublicMeta)
end

return BindingInternalApi]]></ProtectedString>
									<BinaryString name="Tags"></BinaryString>
								</Properties>
							</Item>
							<Item class="ModuleScript" referent="RBX90D84EA497A4498DA46E8647B4F5A237">
								<Properties>
									<Content name="LinkedSource"><null></null></Content>
									<string name="Name">Component</string>
									<string name="ScriptGuid">{043F9759-D3FB-4CD4-92D9-B21DB01B4BFE}</string>
									<ProtectedString name="Source"><![CDATA[local assign = require(script.Parent.assign)
local ComponentLifecyclePhase = require(script.Parent.ComponentLifecyclePhase)
local Type = require(script.Parent.Type)
local Symbol = require(script.Parent.Symbol)
local invalidSetStateMessages = require(script.Parent.invalidSetStateMessages)
local internalAssert = require(script.Parent.internalAssert)

local config = require(script.Parent.GlobalConfig).get()

--[[
	Calling setState during certain lifecycle allowed methods has the potential
	to create an infinitely updating component. Rather than time out, we exit
	with an error if an unreasonable number of self-triggering updates occur
]]
local MAX_PENDING_UPDATES = 100

local InternalData = Symbol.named("InternalData")

local componentMissingRenderMessage = [[
The component %q is missing the `render` method.
`render` must be defined when creating a Roact component!]]

local tooManyUpdatesMessage = [[
The component %q has reached the setState update recursion limit.
When using `setState` in `didUpdate`, make sure that it won't repeat infinitely!]]

local componentClassMetatable = {}

function componentClassMetatable:__tostring()
	return self.__componentName
end

local Component = {}
setmetatable(Component, componentClassMetatable)

Component[Type] = Type.StatefulComponentClass
Component.__index = Component
Component.__componentName = "Component"

--[[
	A method called by consumers of Roact to create a new component class.
	Components can not be extended beyond this point, with the exception of
	PureComponent.
]]
function Component:extend(name)
	if config.typeChecks then
		assert(Type.of(self) == Type.StatefulComponentClass, "Invalid `self` argument to `extend`.")
		assert(typeof(name) == "string", "Component class name must be a string")
	end

	local class = {}

	for key, value in pairs(self) do
		-- Roact opts to make consumers use composition over inheritance, which
		-- lines up with React.
		-- https://reactjs.org/docs/composition-vs-inheritance.html
		if key ~= "extend" then
			class[key] = value
		end
	end

	class[Type] = Type.StatefulComponentClass
	class.__index = class
	class.__componentName = name

	setmetatable(class, componentClassMetatable)

	return class
end

function Component:__getDerivedState(incomingProps, incomingState)
	if config.internalTypeChecks then
		internalAssert(Type.of(self) == Type.StatefulComponentInstance, "Invalid use of `__getDerivedState`")
	end

	local internalData = self[InternalData]
	local componentClass = internalData.componentClass

	if componentClass.getDerivedStateFromProps ~= nil then
		local derivedState = componentClass.getDerivedStateFromProps(incomingProps, incomingState)

		if derivedState ~= nil then
			if config.typeChecks then
				assert(typeof(derivedState) == "table", "getDerivedStateFromProps must return a table!")
			end

			return derivedState
		end
	end

	return nil
end

function Component:setState(mapState)
	if config.typeChecks then
		assert(Type.of(self) == Type.StatefulComponentInstance, "Invalid `self` argument to `extend`.")
	end

	local internalData = self[InternalData]
	local lifecyclePhase = internalData.lifecyclePhase

	--[[
		When preparing to update, rendering, or unmounting, it is not safe
		to call `setState` as it will interfere with in-flight updates. It's
		also disallowed during unmounting
	]]
	if lifecyclePhase == ComponentLifecyclePhase.ShouldUpdate or
		lifecyclePhase == ComponentLifecyclePhase.WillUpdate or
		lifecyclePhase == ComponentLifecyclePhase.Render or
		lifecyclePhase == ComponentLifecyclePhase.WillUnmount
	then
		local messageTemplate = invalidSetStateMessages[internalData.lifecyclePhase]

		local message = messageTemplate:format(tostring(internalData.componentClass))

		error(message, 2)
	end

	local pendingState = internalData.pendingState

	local partialState
	if typeof(mapState) == "function" then
		partialState = mapState(pendingState or self.state, self.props)

		-- Abort the state update if the given state updater function returns nil
		if partialState == nil then
			return
		end
	elseif typeof(mapState) == "table" then
		partialState = mapState
	else
		error("Invalid argument to setState, expected function or table", 2)
	end

	local newState
	if pendingState ~= nil then
		newState = assign(pendingState, partialState)
	else
		newState = assign({}, self.state, partialState)
	end

	if lifecyclePhase == ComponentLifecyclePhase.Init then
		-- If `setState` is called in `init`, we can skip triggering an update!
		local derivedState = self:__getDerivedState(self.props, newState)
		self.state = assign(newState, derivedState)

	elseif lifecyclePhase == ComponentLifecyclePhase.DidMount or
		lifecyclePhase == ComponentLifecyclePhase.DidUpdate or
		lifecyclePhase == ComponentLifecyclePhase.ReconcileChildren
	then
		--[[
			During certain phases of the component lifecycle, it's acceptable to
			allow `setState` but defer the update until we're done with ones in flight.
			We do this by collapsing it into any pending updates we have.
		]]
		local derivedState = self:__getDerivedState(self.props, newState)
		internalData.pendingState = assign(newState, derivedState)

	elseif lifecyclePhase == ComponentLifecyclePhase.Idle then
		-- Outside of our lifecycle, the state update is safe to make immediately
		self:__update(nil, newState)

	else
		local messageTemplate = invalidSetStateMessages.default

		local message = messageTemplate:format(tostring(internalData.componentClass))

		error(message, 2)
	end
end

--[[
	Returns the stack trace of where the element was created that this component
	instance's properties are based on.

	Intended to be used primarily by diagnostic tools.
]]
function Component:getElementTraceback()
	return self[InternalData].virtualNode.currentElement.source
end

--[[
	Returns a snapshot of this component given the current props and state. Must
	be overridden by consumers of Roact and should be a pure function with
	regards to props and state.

	TODO (#199): Accept props and state as arguments.
]]
function Component:render()
	local internalData = self[InternalData]

	local message = componentMissingRenderMessage:format(
		tostring(internalData.componentClass)
	)

	error(message, 0)
end

--[[
	Performs property validation if the static method validateProps is declared.
	validateProps should follow assert's expected arguments:
	(false, message: string) | true. The function may return a message in the
	true case; it will be ignored. If this fails, the function will throw the
	error.
]]
function Component:__validateProps(props)
	if not config.propValidation then
		return
	end

	local validator = self[InternalData].componentClass.validateProps

	if validator == nil then
		return
	end

	if typeof(validator) ~= "function" then
		error(("validateProps must be a function, but it is a %s.\nCheck the definition of the component %q."):format(
			typeof(validator),
			self.__componentName
		))
	end

	local success, failureReason = validator(props)

	if not success then
		failureReason = failureReason or "<Validator function did not supply a message>"
		error(("Property validation failed: %s\n\n%s"):format(
			tostring(failureReason),
			self:getElementTraceback() or "<enable element tracebacks>"),
		0)
	end
end

--[[
	An internal method used by the reconciler to construct a new component
	instance and attach it to the given virtualNode.
]]
function Component:__mount(reconciler, virtualNode)
	if config.internalTypeChecks then
		internalAssert(Type.of(self) == Type.StatefulComponentClass, "Invalid use of `__mount`")
		internalAssert(Type.of(virtualNode) == Type.VirtualNode, "Expected arg #2 to be of type VirtualNode")
	end

	local currentElement = virtualNode.currentElement
	local hostParent = virtualNode.hostParent

	-- Contains all the information that we want to keep from consumers of
	-- Roact, or even other parts of the codebase like the reconciler.
	local internalData = {
		reconciler = reconciler,
		virtualNode = virtualNode,
		componentClass = self,
		lifecyclePhase = ComponentLifecyclePhase.Init,
	}

	local instance = {
		[Type] = Type.StatefulComponentInstance,
		[InternalData] = internalData,
	}

	setmetatable(instance, self)

	virtualNode.instance = instance

	local props = currentElement.props

	if self.defaultProps ~= nil then
		props = assign({}, self.defaultProps, props)
	end

	instance:__validateProps(props)

	instance.props = props

	local newContext = assign({}, virtualNode.context)
	instance._context = newContext

	instance.state = assign({}, instance:__getDerivedState(instance.props, {}))

	if instance.init ~= nil then
		instance:init(instance.props)
	end

	-- It's possible for init() to redefine _context!
	virtualNode.context = instance._context

	internalData.lifecyclePhase = ComponentLifecyclePhase.Render
	local renderResult = instance:render()

	internalData.lifecyclePhase = ComponentLifecyclePhase.ReconcileChildren
	reconciler.updateVirtualNodeWithRenderResult(virtualNode, hostParent, renderResult)

	if instance.didMount ~= nil then
		internalData.lifecyclePhase = ComponentLifecyclePhase.DidMount
		instance:didMount()
	end

	if internalData.pendingState ~= nil then
		-- __update will handle pendingState, so we don't pass any new element or state
		instance:__update(nil, nil)
	end

	internalData.lifecyclePhase = ComponentLifecyclePhase.Idle
end

--[[
	Internal method used by the reconciler to clean up any resources held by
	this component instance.
]]
function Component:__unmount()
	if config.internalTypeChecks then
		internalAssert(Type.of(self) == Type.StatefulComponentInstance, "Invalid use of `__unmount`")
	end

	local internalData = self[InternalData]
	local virtualNode = internalData.virtualNode
	local reconciler = internalData.reconciler

	if self.willUnmount ~= nil then
		internalData.lifecyclePhase = ComponentLifecyclePhase.WillUnmount
		self:willUnmount()
	end

	for _, childNode in pairs(virtualNode.children) do
		reconciler.unmountVirtualNode(childNode)
	end
end

--[[
	Internal method used by setState (to trigger updates based on state) and by
	the reconciler (to trigger updates based on props)

	Returns true if the update was completed, false if it was cancelled by shouldUpdate
]]
function Component:__update(updatedElement, updatedState)
	if config.internalTypeChecks then
		internalAssert(Type.of(self) == Type.StatefulComponentInstance, "Invalid use of `__update`")
		internalAssert(
			Type.of(updatedElement) == Type.Element or updatedElement == nil,
			"Expected arg #1 to be of type Element or nil"
		)
		internalAssert(
			typeof(updatedState) == "table" or updatedState == nil,
			"Expected arg #2 to be of type table or nil"
		)
	end

	local internalData = self[InternalData]
	local componentClass = internalData.componentClass

	local newProps = self.props
	if updatedElement ~= nil then
		newProps = updatedElement.props

		if componentClass.defaultProps ~= nil then
			newProps = assign({}, componentClass.defaultProps, newProps)
		end

		self:__validateProps(newProps)
	end

	local updateCount = 0
	repeat
		local finalState
		local pendingState = nil

		-- Consume any pending state we might have
		if internalData.pendingState ~= nil then
			pendingState = internalData.pendingState
			internalData.pendingState = nil
		end

		-- Consume a standard update to state or props
		if updatedState ~= nil or newProps ~= self.props then
			if pendingState == nil then
				finalState = updatedState or self.state
			else
				finalState = assign(pendingState, updatedState)
			end

			local derivedState = self:__getDerivedState(newProps, finalState)

			if derivedState ~= nil then
				finalState = assign({}, finalState, derivedState)
			end

			updatedState = nil
		else
			finalState = pendingState
		end

		if not self:__resolveUpdate(newProps, finalState) then
			-- If the update was short-circuited, bubble the result up to the caller
			return false
		end

		updateCount = updateCount + 1

		if updateCount > MAX_PENDING_UPDATES then
			error(tooManyUpdatesMessage:format(tostring(internalData.componentClass)), 3)
		end
	until internalData.pendingState == nil

	return true
end

--[[
	Internal method used by __update to apply new props and state

	Returns true if the update was completed, false if it was cancelled by shouldUpdate
]]
function Component:__resolveUpdate(incomingProps, incomingState)
	if config.internalTypeChecks then
		internalAssert(Type.of(self) == Type.StatefulComponentInstance, "Invalid use of `__resolveUpdate`")
	end

	local internalData = self[InternalData]
	local virtualNode = internalData.virtualNode
	local reconciler = internalData.reconciler

	local oldProps = self.props
	local oldState = self.state

	if incomingProps == nil then
		incomingProps = oldProps
	end
	if incomingState == nil then
		incomingState = oldState
	end

	if self.shouldUpdate ~= nil then
		internalData.lifecyclePhase = ComponentLifecyclePhase.ShouldUpdate
		local continueWithUpdate = self:shouldUpdate(incomingProps, incomingState)

		if not continueWithUpdate then
			internalData.lifecyclePhase = ComponentLifecyclePhase.Idle
			return false
		end
	end

	if self.willUpdate ~= nil then
		internalData.lifecyclePhase = ComponentLifecyclePhase.WillUpdate
		self:willUpdate(incomingProps, incomingState)
	end

	internalData.lifecyclePhase = ComponentLifecyclePhase.Render

	self.props = incomingProps
	self.state = incomingState

	local renderResult = virtualNode.instance:render()

	internalData.lifecyclePhase = ComponentLifecyclePhase.ReconcileChildren
	reconciler.updateVirtualNodeWithRenderResult(virtualNode, virtualNode.hostParent, renderResult)

	if self.didUpdate ~= nil then
		internalData.lifecyclePhase = ComponentLifecyclePhase.DidUpdate
		self:didUpdate(oldProps, oldState)
	end

	internalData.lifecyclePhase = ComponentLifecyclePhase.Idle
	return true
end

return Component]]></ProtectedString>
									<BinaryString name="Tags"></BinaryString>
								</Properties>
							</Item>
							<Item class="ModuleScript" referent="RBX47D98B2F06924FC1963DDB81CAF76F1E">
								<Properties>
									<Content name="LinkedSource"><null></null></Content>
									<string name="Name">ComponentLifecyclePhase</string>
									<string name="ScriptGuid">{B501451C-0857-4CE7-8334-E96408D7D112}</string>
									<ProtectedString name="Source"><![CDATA[local Symbol = require(script.Parent.Symbol)
local strict = require(script.Parent.strict)

local ComponentLifecyclePhase = strict({
	-- Component methods
	Init = Symbol.named("init"),
	Render = Symbol.named("render"),
	ShouldUpdate = Symbol.named("shouldUpdate"),
	WillUpdate = Symbol.named("willUpdate"),
	DidMount = Symbol.named("didMount"),
	DidUpdate = Symbol.named("didUpdate"),
	WillUnmount = Symbol.named("willUnmount"),

	-- Phases describing reconciliation status
	ReconcileChildren = Symbol.named("reconcileChildren"),
	Idle = Symbol.named("idle"),
}, "ComponentLifecyclePhase")

return ComponentLifecyclePhase]]></ProtectedString>
									<BinaryString name="Tags"></BinaryString>
								</Properties>
							</Item>
							<Item class="ModuleScript" referent="RBX9219C7226672477996C4712637F1C3A3">
								<Properties>
									<Content name="LinkedSource"><null></null></Content>
									<string name="Name">Config</string>
									<string name="ScriptGuid">{20EE8C25-7F4D-4D3A-8C4E-88F5B0FE198C}</string>
									<ProtectedString name="Source"><![CDATA[--[[
	Exposes an interface to set global configuration values for Roact.

	Configuration can only occur once, and should only be done by an application
	using Roact, not a library.

	Any keys that aren't recognized will cause errors. Configuration is only
	intended for configuring Roact itself, not extensions or libraries.

	Configuration is expected to be set immediately after loading Roact. Setting
	configuration values after an application starts may produce unpredictable
	behavior.
]]

-- Every valid configuration value should be non-nil in this table.
local defaultConfig = {
	-- Enables asserts for internal Roact APIs. Useful for debugging Roact itself.
	["internalTypeChecks"] = false,
	-- Enables stricter type asserts for Roact's public API.
	["typeChecks"] = false,
	-- Enables storage of `debug.traceback()` values on elements for debugging.
	["elementTracing"] = false,
	-- Enables validation of component props in stateful components.
	["propValidation"] = false,
}

-- Build a list of valid configuration values up for debug messages.
local defaultConfigKeys = {}
for key in pairs(defaultConfig) do
	table.insert(defaultConfigKeys, key)
end

local Config = {}

function Config.new()
	local self = {}

	self._currentConfig = setmetatable({}, {
		__index = function(_, key)
			local message = (
				"Invalid global configuration key %q. Valid configuration keys are: %s"
			):format(
				tostring(key),
				table.concat(defaultConfigKeys, ", ")
			)

			error(message, 3)
		end
	})

	-- We manually bind these methods here so that the Config's methods can be
	-- used without passing in self, since they eventually get exposed on the
	-- root Roact object.
	self.set = function(...)
		return Config.set(self, ...)
	end

	self.get = function(...)
		return Config.get(self, ...)
	end

	self.scoped = function(...)
		return Config.scoped(self, ...)
	end

	self.set(defaultConfig)

	return self
end

function Config:set(configValues)
	-- Validate values without changing any configuration.
	-- We only want to apply this configuration if it's valid!
	for key, value in pairs(configValues) do
		if defaultConfig[key] == nil then
			local message = (
				"Invalid global configuration key %q (type %s). Valid configuration keys are: %s"
			):format(
				tostring(key),
				typeof(key),
				table.concat(defaultConfigKeys, ", ")
			)

			error(message, 3)
		end

		-- Right now, all configuration values must be boolean.
		if typeof(value) ~= "boolean" then
			local message = (
				"Invalid value %q (type %s) for global configuration key %q. Valid values are: true, false"
			):format(
				tostring(value),
				typeof(value),
				tostring(key)
			)

			error(message, 3)
		end

		self._currentConfig[key] = value
	end
end

function Config:get()
	return self._currentConfig
end

function Config:scoped(configValues, callback)
	local previousValues = {}
	for key, value in pairs(self._currentConfig) do
		previousValues[key] = value
	end

	self.set(configValues)

	local success, result = pcall(callback)

	self.set(previousValues)

	assert(success, result)
end

return Config]]></ProtectedString>
									<BinaryString name="Tags"></BinaryString>
								</Properties>
							</Item>
							<Item class="ModuleScript" referent="RBX767EC56085C7430D90C876DFDC20D492">
								<Properties>
									<Content name="LinkedSource"><null></null></Content>
									<string name="Name">ElementKind</string>
									<string name="ScriptGuid">{0C9C5B27-CDD7-4117-A3CF-C808B6BA5C94}</string>
									<ProtectedString name="Source"><![CDATA[--[[
	Contains markers for annotating the type of an element.

	Use `ElementKind` as a key, and values from it as the value.

		local element = {
			[ElementKind] = ElementKind.Host,
		}
]]

local Symbol = require(script.Parent.Symbol)
local strict = require(script.Parent.strict)
local Portal = require(script.Parent.Portal)

local ElementKind = newproxy(true)

local ElementKindInternal = {
	Portal = Symbol.named("Portal"),
	Host = Symbol.named("Host"),
	Function = Symbol.named("Function"),
	Stateful = Symbol.named("Stateful"),
}

function ElementKindInternal.of(value)
	if typeof(value) ~= "table" then
		return nil
	end

	return value[ElementKind]
end

local componentTypesToKinds = {
	["string"] = ElementKindInternal.Host,
	["function"] = ElementKindInternal.Function,
	["table"] = ElementKindInternal.Stateful,
}

function ElementKindInternal.fromComponent(component)
	if component == Portal then
		return ElementKind.Portal
	else
		return componentTypesToKinds[typeof(component)]
	end
end

getmetatable(ElementKind).__index = ElementKindInternal

strict(ElementKindInternal, "ElementKind")

return ElementKind]]></ProtectedString>
									<BinaryString name="Tags"></BinaryString>
								</Properties>
							</Item>
							<Item class="ModuleScript" referent="RBX09B44C4520C24F9981091448587F74A1">
								<Properties>
									<Content name="LinkedSource"><null></null></Content>
									<string name="Name">ElementUtils</string>
									<string name="ScriptGuid">{0C19801B-04DD-4CBB-ACCF-40EAE8F79884}</string>
									<ProtectedString name="Source"><![CDATA[local Type = require(script.Parent.Type)
local Symbol = require(script.Parent.Symbol)

local function noop()
	return nil
end

local ElementUtils = {}

--[[
	A signal value indicating that a child should use its parent's key, because
	it has no key of its own.

	This occurs when you return only one element from a function component or
	stateful render function.
]]
ElementUtils.UseParentKey = Symbol.named("UseParentKey")

--[[
	Returns an iterator over the children of an element.
	`elementOrElements` may be one of:
	* a boolean
	* nil
	* a single element
	* a fragment
	* a table of elements

	If `elementOrElements` is a boolean or nil, this will return an iterator with
	zero elements.

	If `elementOrElements` is a single element, this will return an iterator with
	one element: a tuple where the first value is ElementUtils.UseParentKey, and
	the second is the value of `elementOrElements`.

	If `elementOrElements` is a fragment or a table, this will return an iterator
	over all the elements of the array.

	If `elementOrElements` is none of the above, this function will throw.
]]
function ElementUtils.iterateElements(elementOrElements)
	local richType = Type.of(elementOrElements)

	if richType == Type.Fragment then
		return pairs(elementOrElements.elements)
	end

	-- Single child
	if richType == Type.Element then
		local called = false

		return function()
			if called then
				return nil
			else
				called = true
				return ElementUtils.UseParentKey, elementOrElements
			end
		end
	end

	local regularType = typeof(elementOrElements)

	if elementOrElements == nil or regularType == "boolean" then
		return noop
	end

	if regularType == "table" then
		return pairs(elementOrElements)
	end

	error("Invalid elements")
end

--[[
	Gets the child corresponding to a given key, respecting Roact's rules for
	children. Specifically:
	* If `elements` is nil or a boolean, this will return `nil`, regardless of
		the key given.
	* If `elements` is a single element, this will return `nil`, unless the key
		is ElementUtils.UseParentKey.
	* If `elements` is a table of elements, this will return `elements[key]`.
]]
function ElementUtils.getElementByKey(elements, hostKey)
	if elements == nil or typeof(elements) == "boolean" then
		return nil
	end

	if Type.of(elements) == Type.Element then
		if hostKey == ElementUtils.UseParentKey then
			return elements
		end

		return nil
	end

	if Type.of(elements) == Type.Fragment then
		return elements.elements[hostKey]
	end

	if typeof(elements) == "table" then
		return elements[hostKey]
	end

	error("Invalid elements")
end

return ElementUtils]]></ProtectedString>
									<BinaryString name="Tags"></BinaryString>
								</Properties>
							</Item>
							<Item class="ModuleScript" referent="RBXC6F7C05604E54CA299EAA9E614DB487E">
								<Properties>
									<Content name="LinkedSource"><null></null></Content>
									<string name="Name">GlobalConfig</string>
									<string name="ScriptGuid">{6A51C49B-8A0D-4155-AA78-7ECEC24E43CC}</string>
									<ProtectedString name="Source"><![CDATA[--[[
	Exposes a single instance of a configuration as Roact's GlobalConfig.
]]

local Config = require(script.Parent.Config)

return Config.new()]]></ProtectedString>
									<BinaryString name="Tags"></BinaryString>
								</Properties>
							</Item>
							<Item class="ModuleScript" referent="RBX0670E6D226334246B531E65544B2138D">
								<Properties>
									<Content name="LinkedSource"><null></null></Content>
									<string name="Name">Logging</string>
									<string name="ScriptGuid">{D6B91E11-EB22-4ABC-A4E2-AEBFA6DAA6AD}</string>
									<ProtectedString name="Source"><![CDATA[--[[
	Centralized place to handle logging. Lets us:
	- Unit test log output via `Logging.capture`
	- Disable verbose log messages when not debugging Roact

	This should be broken out into a separate library with the addition of
	scoping and logging configuration.
]]

-- Determines whether log messages will go to stdout/stderr
local outputEnabled = true

-- A set of LogInfo objects that should have messages inserted into them.
-- This is a set so that nested calls to Logging.capture will behave.
local collectors = {}

-- A set of all stack traces that have called warnOnce.
local onceUsedLocations = {}

--[[
	Indent a potentially multi-line string with the given number of tabs, in
	addition to any indentation the string already has.
]]
local function indent(source, indentLevel)
	local indentString = ("\t"):rep(indentLevel)

	return indentString .. source:gsub("\n", "\n" .. indentString)
end

--[[
	Indents a list of strings and then concatenates them together with newlines
	into a single string.
]]
local function indentLines(lines, indentLevel)
	local outputBuffer = {}

	for _, line in ipairs(lines) do
		table.insert(outputBuffer, indent(line, indentLevel))
	end

	return table.concat(outputBuffer, "\n")
end

local logInfoMetatable = {}

--[[
	Automatic coercion to strings for LogInfo objects to enable debugging them
	more easily.
]]
function logInfoMetatable:__tostring()
	local outputBuffer = {"LogInfo {"}

	local errorCount = #self.errors
	local warningCount = #self.warnings
	local infosCount = #self.infos

	if errorCount + warningCount + infosCount == 0 then
		table.insert(outputBuffer, "\t(no messages)")
	end

	if errorCount > 0 then
		table.insert(outputBuffer, ("\tErrors (%d) {"):format(errorCount))
		table.insert(outputBuffer, indentLines(self.errors, 2))
		table.insert(outputBuffer, "\t}")
	end

	if warningCount > 0 then
		table.insert(outputBuffer, ("\tWarnings (%d) {"):format(warningCount))
		table.insert(outputBuffer, indentLines(self.warnings, 2))
		table.insert(outputBuffer, "\t}")
	end

	if infosCount > 0 then
		table.insert(outputBuffer, ("\tInfos (%d) {"):format(infosCount))
		table.insert(outputBuffer, indentLines(self.infos, 2))
		table.insert(outputBuffer, "\t}")
	end

	table.insert(outputBuffer, "}")

	return table.concat(outputBuffer, "\n")
end

local function createLogInfo()
	local logInfo = {
		errors = {},
		warnings = {},
		infos = {},
	}

	setmetatable(logInfo, logInfoMetatable)

	return logInfo
end

local Logging = {}

--[[
	Invokes `callback`, capturing all output that happens during its execution.

	Output will not go to stdout or stderr and will instead be put into a
	LogInfo object that is returned. If `callback` throws, the error will be
	bubbled up to the caller of `Logging.capture`.
]]
function Logging.capture(callback)
	local collector = createLogInfo()

	local wasOutputEnabled = outputEnabled
	outputEnabled = false
	collectors[collector] = true

	local success, result = pcall(callback)

	collectors[collector] = nil
	outputEnabled = wasOutputEnabled

	assert(success, result)

	return collector
end

--[[
	Issues a warning with an automatically attached stack trace.
]]
function Logging.warn(messageTemplate, ...)
	local message = messageTemplate:format(...)

	for collector in pairs(collectors) do
		table.insert(collector.warnings, message)
	end

	-- debug.traceback inserts a leading newline, so we trim it here
	local trace = debug.traceback("", 2):sub(2)
	local fullMessage = ("%s\n%s"):format(message, indent(trace, 1))

	if outputEnabled then
		warn(fullMessage)
	end
end

--[[
	Issues a warning like `Logging.warn`, but only outputs once per call site.

	This is useful for marking deprecated functions that might be called a lot;
	using `warnOnce` instead of `warn` will reduce output noise while still
	correctly marking all call sites.
]]
function Logging.warnOnce(messageTemplate, ...)
	local trace = debug.traceback()

	if onceUsedLocations[trace] then
		return
	end

	onceUsedLocations[trace] = true
	Logging.warn(messageTemplate, ...)
end

return Logging]]></ProtectedString>
									<BinaryString name="Tags"></BinaryString>
								</Properties>
							</Item>
							<Item class="ModuleScript" referent="RBXFC5FDDE9299F4D5287B6353D152EF345">
								<Properties>
									<Content name="LinkedSource"><null></null></Content>
									<string name="Name">None</string>
									<string name="ScriptGuid">{90C6C6C3-2D13-41FC-9275-842D5E73D9ED}</string>
									<ProtectedString name="Source"><![CDATA[local Symbol = require(script.Parent.Symbol)

-- Marker used to specify that the value is nothing, because nil cannot be
-- stored in tables.
local None = Symbol.named("None")

return None]]></ProtectedString>
									<BinaryString name="Tags"></BinaryString>
								</Properties>
							</Item>
							<Item class="ModuleScript" referent="RBX1DBED0C73CA54140A9D2078FDCFD300D">
								<Properties>
									<Content name="LinkedSource"><null></null></Content>
									<string name="Name">NoopRenderer</string>
									<string name="ScriptGuid">{2425723F-096F-4BCC-A7DD-F55D5E455C3B}</string>
									<ProtectedString name="Source"><![CDATA[--[[
	Reference renderer intended for use in tests as well as for documenting the
	minimum required interface for a Roact renderer.
]]

local NoopRenderer = {}

function NoopRenderer.isHostObject(target)
	-- Attempting to use NoopRenderer to target a Roblox instance is almost
	-- certainly a mistake.
	return target == nil
end

function NoopRenderer.mountHostNode(reconciler, node)
end

function NoopRenderer.unmountHostNode(reconciler, node)
end

function NoopRenderer.updateHostNode(reconciler, node, newElement)
	return node
end

return NoopRenderer]]></ProtectedString>
									<BinaryString name="Tags"></BinaryString>
								</Properties>
							</Item>
							<Item class="ModuleScript" referent="RBXFB9516CED97C4212B9135C6D4E005734">
								<Properties>
									<Content name="LinkedSource"><null></null></Content>
									<string name="Name">Portal</string>
									<string name="ScriptGuid">{05540EC1-CCA7-4613-9A5E-E6FD049085EE}</string>
									<ProtectedString name="Source"><![CDATA[local Symbol = require(script.Parent.Symbol)

local Portal = Symbol.named("Portal")

return Portal]]></ProtectedString>
									<BinaryString name="Tags"></BinaryString>
								</Properties>
							</Item>
							<Item class="Folder" referent="RBX393F3221482C481294BEF04A05AAE762">
								<Properties>
									<string name="Name">PropMarkers</string>
									<BinaryString name="Tags"></BinaryString>
								</Properties>
								<Item class="ModuleScript" referent="RBX14901F41368849A5961F5BD1E4D58697">
									<Properties>
										<Content name="LinkedSource"><null></null></Content>
										<string name="Name">Change</string>
										<string name="ScriptGuid">{87CAEC67-B681-496E-8B9F-FFCB65B0328F}</string>
										<ProtectedString name="Source"><![CDATA[--[[
	Change is used to generate special prop keys that can be used to connect to
	GetPropertyChangedSignal.

	Generally, Change is indexed by a Roblox property name:

		Roact.createElement("TextBox", {
			[Roact.Change.Text] = function(rbx)
				print("The TextBox", rbx, "changed text to", rbx.Text)
			end,
		})
]]

local Type = require(script.Parent.Parent.Type)

local Change = {}

local changeMetatable = {
	__tostring = function(self)
		return ("RoactHostChangeEvent(%s)"):format(self.name)
	end,
}

setmetatable(Change, {
	__index = function(self, propertyName)
		local changeListener = {
			[Type] = Type.HostChangeEvent,
			name = propertyName
		}

		setmetatable(changeListener, changeMetatable)
		Change[propertyName] = changeListener

		return changeListener
	end,
})

return Change]]></ProtectedString>
										<BinaryString name="Tags"></BinaryString>
									</Properties>
								</Item>
								<Item class="ModuleScript" referent="RBX01589A8F7D8743D48590E01C3433807C">
									<Properties>
										<Content name="LinkedSource"><null></null></Content>
										<string name="Name">Children</string>
										<string name="ScriptGuid">{2423BFAC-DB55-4B97-BFE1-46252FDD23B2}</string>
										<ProtectedString name="Source"><![CDATA[local Symbol = require(script.Parent.Parent.Symbol)

local Children = Symbol.named("Children")

return Children]]></ProtectedString>
										<BinaryString name="Tags"></BinaryString>
									</Properties>
								</Item>
								<Item class="ModuleScript" referent="RBX0C79F363D3B2412D98A140F62D127887">
									<Properties>
										<Content name="LinkedSource"><null></null></Content>
										<string name="Name">Event</string>
										<string name="ScriptGuid">{FE671409-93C2-4B8F-9DCE-6F453EBD14E7}</string>
										<ProtectedString name="Source"><![CDATA[--[[
	Index into `Event` to get a prop key for attaching to an event on a Roblox
	Instance.

	Example:

		Roact.createElement("TextButton", {
			Text = "Hello, world!",

			[Roact.Event.MouseButton1Click] = function(rbx)
				print("Clicked", rbx)
			end
		})
]]

local Type = require(script.Parent.Parent.Type)

local Event = {}

local eventMetatable = {
	__tostring = function(self)
		return ("RoactHostEvent(%s)"):format(self.name)
	end,
}

setmetatable(Event, {
	__index = function(self, eventName)
		local event = {
			[Type] = Type.HostEvent,
			name = eventName,
		}

		setmetatable(event, eventMetatable)

		Event[eventName] = event

		return event
	end
})

return Event]]></ProtectedString>
										<BinaryString name="Tags"></BinaryString>
									</Properties>
								</Item>
								<Item class="ModuleScript" referent="RBX693D2EFD27804660BEB31C35B8B13AE0">
									<Properties>
										<Content name="LinkedSource"><null></null></Content>
										<string name="Name">Ref</string>
										<string name="ScriptGuid">{74F9B28F-5FC8-4458-9243-E2AC0B542A71}</string>
										<ProtectedString name="Source"><![CDATA[local Symbol = require(script.Parent.Parent.Symbol)

local Ref = Symbol.named("Ref")

return Ref]]></ProtectedString>
										<BinaryString name="Tags"></BinaryString>
									</Properties>
								</Item>
							</Item>
							<Item class="ModuleScript" referent="RBX0E2D0B5232A54BE28A8D8CAC4C8A9187">
								<Properties>
									<Content name="LinkedSource"><null></null></Content>
									<string name="Name">PureComponent</string>
									<string name="ScriptGuid">{5DD8D007-EC55-4664-A966-53C52A10DC04}</string>
									<ProtectedString name="Source"><![CDATA[--[[
	A version of Component with a `shouldUpdate` method that forces the
	resulting component to be pure.
]]

local Component = require(script.Parent.Component)

local PureComponent = Component:extend("PureComponent")

-- When extend()ing a component, you don't get an extend method.
-- This is to promote composition over inheritance.
-- PureComponent is an exception to this rule.
PureComponent.extend = Component.extend

function PureComponent:shouldUpdate(newProps, newState)
	-- In a vast majority of cases, if state updated, something has updated.
	-- We don't bother checking in this case.
	if newState ~= self.state then
		return true
	end

	if newProps == self.props then
		return false
	end

	for key, value in pairs(newProps) do
		if self.props[key] ~= value then
			return true
		end
	end

	for key, value in pairs(self.props) do
		if newProps[key] ~= value then
			return true
		end
	end

	return false
end

return PureComponent]]></ProtectedString>
									<BinaryString name="Tags"></BinaryString>
								</Properties>
							</Item>
							<Item class="ModuleScript" referent="RBXFC7F168523334F9381D99244D9F1A9A0">
								<Properties>
									<Content name="LinkedSource"><null></null></Content>
									<string name="Name">RobloxRenderer</string>
									<string name="ScriptGuid">{824BDA74-5B44-4234-A9E0-487936192501}</string>
									<ProtectedString name="Source"><![CDATA[--[[
	Renderer that deals in terms of Roblox Instances. This is the most
	well-supported renderer after NoopRenderer and is currently the only
	renderer that does anything.
]]

local Binding = require(script.Parent.Binding)
local Children = require(script.Parent.PropMarkers.Children)
local ElementKind = require(script.Parent.ElementKind)
local SingleEventManager = require(script.Parent.SingleEventManager)
local getDefaultInstanceProperty = require(script.Parent.getDefaultInstanceProperty)
local Ref = require(script.Parent.PropMarkers.Ref)
local Type = require(script.Parent.Type)
local internalAssert = require(script.Parent.internalAssert)

local config = require(script.Parent.GlobalConfig).get()

local applyPropsError = [[
Error applying props:
	%s
In element:
%s
]]

local updatePropsError = [[
Error updating props:
	%s
In element:
%s
]]

local function identity(...)
	return ...
end

local function applyRef(ref, newHostObject)
	if ref == nil then
		return
	end

	if typeof(ref) == "function" then
		ref(newHostObject)
	elseif Type.of(ref) == Type.Binding then
		Binding.update(ref, newHostObject)
	else
		-- TODO (#197): Better error message
		error(("Invalid ref: Expected type Binding but got %s"):format(
			typeof(ref)
		))
	end
end

local function setRobloxInstanceProperty(hostObject, key, newValue)
	if newValue == nil then
		local hostClass = hostObject.ClassName
		local _, defaultValue = getDefaultInstanceProperty(hostClass, key)
		newValue = defaultValue
	end

	-- Assign the new value to the object
	hostObject[key] = newValue

	return
end

local function removeBinding(virtualNode, key)
	local disconnect = virtualNode.bindings[key]
	disconnect()
	virtualNode.bindings[key] = nil
end

local function attachBinding(virtualNode, key, newBinding)
	local function updateBoundProperty(newValue)
		local success, errorMessage = xpcall(function()
			setRobloxInstanceProperty(virtualNode.hostObject, key, newValue)
		end, identity)

		if not success then
			local source = virtualNode.currentElement.source

			if source == nil then
				source = "<enable element tracebacks>"
			end

			local fullMessage = updatePropsError:format(errorMessage, source)
			error(fullMessage, 0)
		end
	end

	if virtualNode.bindings == nil then
		virtualNode.bindings = {}
	end

	virtualNode.bindings[key] = Binding.subscribe(newBinding, updateBoundProperty)

	updateBoundProperty(newBinding:getValue())
end

local function detachAllBindings(virtualNode)
	if virtualNode.bindings ~= nil then
		for _, disconnect in pairs(virtualNode.bindings) do
			disconnect()
		end
	end
end

local function applyProp(virtualNode, key, newValue, oldValue)
	if newValue == oldValue then
		return
	end

	if key == Ref or key == Children then
		-- Refs and children are handled in a separate pass
		return
	end

	local internalKeyType = Type.of(key)

	if internalKeyType == Type.HostEvent or internalKeyType == Type.HostChangeEvent then
		if virtualNode.eventManager == nil then
			virtualNode.eventManager = SingleEventManager.new(virtualNode.hostObject)
		end

		local eventName = key.name

		if internalKeyType == Type.HostChangeEvent then
			virtualNode.eventManager:connectPropertyChange(eventName, newValue)
		else
			virtualNode.eventManager:connectEvent(eventName, newValue)
		end

		return
	end

	local newIsBinding = Type.of(newValue) == Type.Binding
	local oldIsBinding = Type.of(oldValue) == Type.Binding

	if oldIsBinding then
		removeBinding(virtualNode, key)
	end

	if newIsBinding then
		attachBinding(virtualNode, key, newValue)
	else
		setRobloxInstanceProperty(virtualNode.hostObject, key, newValue)
	end
end

local function applyProps(virtualNode, props)
	for propKey, value in pairs(props) do
		applyProp(virtualNode, propKey, value, nil)
	end
end

local function updateProps(virtualNode, oldProps, newProps)
	-- Apply props that were added or updated
	for propKey, newValue in pairs(newProps) do
		local oldValue = oldProps[propKey]

		applyProp(virtualNode, propKey, newValue, oldValue)
	end

	-- Clean up props that were removed
	for propKey, oldValue in pairs(oldProps) do
		local newValue = newProps[propKey]

		if newValue == nil then
			applyProp(virtualNode, propKey, nil, oldValue)
		end
	end
end

local RobloxRenderer = {}

function RobloxRenderer.isHostObject(target)
	return typeof(target) == "Instance"
end

function RobloxRenderer.mountHostNode(reconciler, virtualNode)
	local element = virtualNode.currentElement
	local hostParent = virtualNode.hostParent
	local hostKey = virtualNode.hostKey

	if config.internalTypeChecks then
		internalAssert(ElementKind.of(element) == ElementKind.Host, "Element at given node is not a host Element")
	end
	if config.typeChecks then
		assert(element.props.Name == nil, "Name can not be specified as a prop to a host component in Roact.")
		assert(element.props.Parent == nil, "Parent can not be specified as a prop to a host component in Roact.")
	end

	local instance = Instance.new(element.component)
	virtualNode.hostObject = instance

	local success, errorMessage = xpcall(function()
		applyProps(virtualNode, element.props)
	end, identity)

	if not success then
		local source = element.source

		if source == nil then
			source = "<enable element tracebacks>"
		end

		local fullMessage = applyPropsError:format(errorMessage, source)
		error(fullMessage, 0)
	end

	instance.Name = tostring(hostKey)

	local children = element.props[Children]

	if children ~= nil then
		reconciler.updateVirtualNodeWithChildren(virtualNode, virtualNode.hostObject, children)
	end

	instance.Parent = hostParent
	virtualNode.hostObject = instance

	applyRef(element.props[Ref], instance)

	if virtualNode.eventManager ~= nil then
		virtualNode.eventManager:resume()
	end
end

function RobloxRenderer.unmountHostNode(reconciler, virtualNode)
	local element = virtualNode.currentElement

	applyRef(element.props[Ref], nil)

	for _, childNode in pairs(virtualNode.children) do
		reconciler.unmountVirtualNode(childNode)
	end

	detachAllBindings(virtualNode)

	virtualNode.hostObject:Destroy()
end

function RobloxRenderer.updateHostNode(reconciler, virtualNode, newElement)
	local oldProps = virtualNode.currentElement.props
	local newProps = newElement.props

	if virtualNode.eventManager ~= nil then
		virtualNode.eventManager:suspend()
	end

	-- If refs changed, detach the old ref and attach the new one
	if oldProps[Ref] ~= newProps[Ref] then
		applyRef(oldProps[Ref], nil)
		applyRef(newProps[Ref], virtualNode.hostObject)
	end

	local success, errorMessage = xpcall(function()
		updateProps(virtualNode, oldProps, newProps)
	end, identity)

	if not success then
		local source = newElement.source

		if source == nil then
			source = "<enable element tracebacks>"
		end

		local fullMessage = updatePropsError:format(errorMessage, source)
		error(fullMessage, 0)
	end

	local children = newElement.props[Children]
	if children ~= nil or oldProps[Children] ~= nil then
		reconciler.updateVirtualNodeWithChildren(virtualNode, virtualNode.hostObject, children)
	end

	if virtualNode.eventManager ~= nil then
		virtualNode.eventManager:resume()
	end

	return virtualNode
end

return RobloxRenderer
]]></ProtectedString>
									<BinaryString name="Tags"></BinaryString>
								</Properties>
							</Item>
							<Item class="ModuleScript" referent="RBXF8C18AA4C908499B8623C480A5748B53">
								<Properties>
									<Content name="LinkedSource"><null></null></Content>
									<string name="Name">SingleEventManager</string>
									<string name="ScriptGuid">{1472BE19-9DC2-4C45-B3C3-E6D72AF3E61C}</string>
									<ProtectedString name="Source"><![CDATA[--[[
	A manager for a single host virtual node's connected events.
]]

local Logging = require(script.Parent.Logging)

local CHANGE_PREFIX = "Change."

local EventStatus = {
	-- No events are processed at all; they're silently discarded
	Disabled = "Disabled",

	-- Events are stored in a queue; listeners are invoked when the manager is resumed
	Suspended = "Suspended",

	-- Event listeners are invoked as the events fire
	Enabled = "Enabled",
}

local SingleEventManager = {}
SingleEventManager.__index = SingleEventManager

function SingleEventManager.new(instance)
	local self = setmetatable({
		-- The queue of suspended events
		_suspendedEventQueue = {},

		-- All the event connections being managed
		-- Events are indexed by a string key
		_connections = {},

		-- All the listeners being managed
		-- These are stored distinctly from the connections
		-- Connections can have their listeners replaced at runtime
		_listeners = {},

		-- The suspension status of the manager
		-- Managers start disabled and are "resumed" after the initial render
		_status = EventStatus.Disabled,

		-- If true, the manager is processing queued events right now.
		_isResuming = false,

		-- The Roblox instance the manager is managing
		_instance = instance,
	}, SingleEventManager)

	return self
end

function SingleEventManager:connectEvent(key, listener)
	self:_connect(key, self._instance[key], listener)
end

function SingleEventManager:connectPropertyChange(key, listener)
	local event = self._instance:GetPropertyChangedSignal(key)
	self:_connect(CHANGE_PREFIX .. key, event, listener)
end

function SingleEventManager:_connect(eventKey, event, listener)
	-- If the listener doesn't exist we can just disconnect the existing connection
	if listener == nil then
		if self._connections[eventKey] ~= nil then
			self._connections[eventKey]:Disconnect()
			self._connections[eventKey] = nil
		end

		self._listeners[eventKey] = nil
	else
		if self._connections[eventKey] == nil then
			self._connections[eventKey] = event:Connect(function(...)
				if self._status == EventStatus.Enabled then
					self._listeners[eventKey](self._instance, ...)
				elseif self._status == EventStatus.Suspended then
					-- Store this event invocation to be fired when resume is
					-- called.

					local argumentCount = select("#", ...)
					table.insert(self._suspendedEventQueue, { eventKey, argumentCount, ... })
				end
			end)
		end

		self._listeners[eventKey] = listener
	end
end

function SingleEventManager:suspend()
	self._status = EventStatus.Suspended
end

function SingleEventManager:resume()
	-- If we're already resuming events for this instance, trying to resume
	-- again would cause a disaster.
	if self._isResuming then
		return
	end

	self._isResuming = true

	local index = 1

	-- More events might be added to the queue when evaluating events, so we
	-- need to be careful in order to preserve correct evaluation order.
	while index <= #self._suspendedEventQueue do
		local eventInvocation = self._suspendedEventQueue[index]
		local listener = self._listeners[eventInvocation[1]]
		local argumentCount = eventInvocation[2]

		-- The event might have been disconnected since suspension started; in
		-- this case, we drop the event.
		if listener ~= nil then
			-- Wrap the listener in a coroutine to catch errors and handle
			-- yielding correctly.
			local listenerCo = coroutine.create(listener)
			local success, result = coroutine.resume(
				listenerCo,
				self._instance,
				unpack(eventInvocation, 3, 2 + argumentCount))

			-- If the listener threw an error, we log it as a warning, since
			-- there's no way to write error text in Roblox Lua without killing
			-- our thread!
			if not success then
				Logging.warn("%s", result)
			end
		end

		index = index + 1
	end

	self._isResuming = false
	self._status = EventStatus.Enabled
	self._suspendedEventQueue = {}
end

return SingleEventManager]]></ProtectedString>
									<BinaryString name="Tags"></BinaryString>
								</Properties>
							</Item>
							<Item class="ModuleScript" referent="RBX07BE6419FDA14DDD84CEAAF585C4E8AA">
								<Properties>
									<Content name="LinkedSource"><null></null></Content>
									<string name="Name">Symbol</string>
									<string name="ScriptGuid">{7B9A76CF-BED6-40D5-8575-A0C3D2A0EA4C}</string>
									<ProtectedString name="Source"><![CDATA[--[[
	A 'Symbol' is an opaque marker type.

	Symbols have the type 'userdata', but when printed to the console, the name
	of the symbol is shown.
]]

local Symbol = {}

--[[
	Creates a Symbol with the given name.

	When printed or coerced to a string, the symbol will turn into the string
	given as its name.
]]
function Symbol.named(name)
	assert(type(name) == "string", "Symbols must be created using a string name!")

	local self = newproxy(true)

	local wrappedName = ("Symbol(%s)"):format(name)

	getmetatable(self).__tostring = function()
		return wrappedName
	end

	return self
end

return Symbol]]></ProtectedString>
									<BinaryString name="Tags"></BinaryString>
								</Properties>
							</Item>
							<Item class="ModuleScript" referent="RBXE09B720165F24DF4929FD4A8A0244504">
								<Properties>
									<Content name="LinkedSource"><null></null></Content>
									<string name="Name">Type</string>
									<string name="ScriptGuid">{D01F405D-4D7B-459B-AE79-458D4064D1E0}</string>
									<ProtectedString name="Source"><![CDATA[--[[
	Contains markers for annotating objects with types.

	To set the type of an object, use `Type` as a key and the actual marker as
	the value:

		local foo = {
			[Type] = Type.Foo,
		}
]]

local Symbol = require(script.Parent.Symbol)
local strict = require(script.Parent.strict)

local Type = newproxy(true)

local TypeInternal = {}

local function addType(name)
	TypeInternal[name] = Symbol.named("Roact" .. name)
end

addType("Binding")
addType("Element")
addType("Fragment")
addType("HostChangeEvent")
addType("HostEvent")
addType("StatefulComponentClass")
addType("StatefulComponentInstance")
addType("VirtualNode")
addType("VirtualTree")

function TypeInternal.of(value)
	if typeof(value) ~= "table" then
		return nil
	end

	return value[Type]
end

getmetatable(Type).__index = TypeInternal

getmetatable(Type).__tostring = function()
	return "RoactType"
end

strict(TypeInternal, "Type")

return Type]]></ProtectedString>
									<BinaryString name="Tags"></BinaryString>
								</Properties>
							</Item>
							<Item class="ModuleScript" referent="RBXA19E4FA3D9FC408888615C7D210D178F">
								<Properties>
									<Content name="LinkedSource"><null></null></Content>
									<string name="Name">assertDeepEqual</string>
									<string name="ScriptGuid">{19B6DDA3-8256-46B6-9B0B-1C48E18043AC}</string>
									<ProtectedString name="Source"><![CDATA[--[[
	A utility used to assert that two objects are value-equal recursively. It
	outputs fairly nicely formatted messages to help diagnose why two objects
	would be different.

	This should only be used in tests.
]]

local function deepEqual(a, b)
	if typeof(a) ~= typeof(b) then
		local message = ("{1} is of type %s, but {2} is of type %s"):format(
			typeof(a),
			typeof(b)
		)
		return false, message
	end

	if typeof(a) == "table" then
		local visitedKeys = {}

		for key, value in pairs(a) do
			visitedKeys[key] = true

			local success, innerMessage = deepEqual(value, b[key])
			if not success then
				local message = innerMessage
					:gsub("{1}", ("{1}[%s]"):format(tostring(key)))
					:gsub("{2}", ("{2}[%s]"):format(tostring(key)))

				return false, message
			end
		end

		for key, value in pairs(b) do
			if not visitedKeys[key] then
				local success, innerMessage = deepEqual(value, a[key])

				if not success then
					local message = innerMessage
						:gsub("{1}", ("{1}[%s]"):format(tostring(key)))
						:gsub("{2}", ("{2}[%s]"):format(tostring(key)))

					return false, message
				end
			end
		end

		return true
	end

	if a == b then
		return true
	end

	local message = "{1} ~= {2}"
	return false, message
end

local function assertDeepEqual(a, b)
	local success, innerMessageTemplate = deepEqual(a, b)

	if not success then
		local innerMessage = innerMessageTemplate
			:gsub("{1}", "first")
			:gsub("{2}", "second")

		local message = ("Values were not deep-equal.\n%s"):format(innerMessage)

		error(message, 2)
	end
end

return assertDeepEqual]]></ProtectedString>
									<BinaryString name="Tags"></BinaryString>
								</Properties>
							</Item>
							<Item class="ModuleScript" referent="RBXAB18317D426D40A18BCB5AAC6AE91D1A">
								<Properties>
									<Content name="LinkedSource"><null></null></Content>
									<string name="Name">assign</string>
									<string name="ScriptGuid">{3065CAA8-E5F2-4667-898C-2858ED7D4079}</string>
									<ProtectedString name="Source"><![CDATA[local None = require(script.Parent.None)

--[[
	Merges values from zero or more tables onto a target table. If a value is
	set to None, it will instead be removed from the table.

	This function is identical in functionality to JavaScript's Object.assign.
]]
local function assign(target, ...)
	for index = 1, select("#", ...) do
		local source = select(index, ...)

		if source ~= nil then
			for key, value in pairs(source) do
				if value == None then
					target[key] = nil
				else
					target[key] = value
				end
			end
		end
	end

	return target
end

return assign]]></ProtectedString>
									<BinaryString name="Tags"></BinaryString>
								</Properties>
							</Item>
							<Item class="ModuleScript" referent="RBXBF458E720AB14E84817AA3A7F3BED94B">
								<Properties>
									<Content name="LinkedSource"><null></null></Content>
									<string name="Name">createElement</string>
									<string name="ScriptGuid">{6B3C8667-8877-4149-B259-B9C62BD69D70}</string>
									<ProtectedString name="Source"><![CDATA[local Children = require(script.Parent.PropMarkers.Children)
local ElementKind = require(script.Parent.ElementKind)
local Logging = require(script.Parent.Logging)
local Type = require(script.Parent.Type)

local config = require(script.Parent.GlobalConfig).get()

local multipleChildrenMessage = [[
The prop `Roact.Children` was defined but was overriden by the third parameter to createElement!
This can happen when a component passes props through to a child element but also uses the `children` argument:

	Roact.createElement("Frame", passedProps, {
		child = ...
	})

Instead, consider using a utility function to merge tables of children together:

	local children = mergeTables(passedProps[Roact.Children], {
		child = ...
	})

	local fullProps = mergeTables(passedProps, {
		[Roact.Children] = children
	})

	Roact.createElement("Frame", fullProps)]]

--[[
	Creates a new element representing the given component.

	Elements are lightweight representations of what a component instance should
	look like.

	Children is a shorthand for specifying `Roact.Children` as a key inside
	props. If specified, the passed `props` table is mutated!
]]
local function createElement(component, props, children)
	if config.typeChecks then
		assert(component ~= nil, "`component` is required")
		assert(typeof(props) == "table" or props == nil, "`props` must be a table or nil")
		assert(typeof(children) == "table" or children == nil, "`children` must be a table or nil")
	end

	if props == nil then
		props = {}
	end

	if children ~= nil then
		if props[Children] ~= nil then
			Logging.warnOnce(multipleChildrenMessage)
		end

		props[Children] = children
	end

	local elementKind = ElementKind.fromComponent(component)

	local element = {
		[Type] = Type.Element,
		[ElementKind] = elementKind,
		component = component,
		props = props,
	}

	if config.elementTracing then
		-- We trim out the leading newline since there's no way to specify the
		-- trace level without also specifying a message.
		element.source = debug.traceback("", 2):sub(2)
	end

	return element
end

return createElement]]></ProtectedString>
									<BinaryString name="Tags"></BinaryString>
								</Properties>
							</Item>
							<Item class="ModuleScript" referent="RBX0E3ADD19DBD344149D31B21C542F428D">
								<Properties>
									<Content name="LinkedSource"><null></null></Content>
									<string name="Name">createFragment</string>
									<string name="ScriptGuid">{6DB48EE2-5D59-48DE-A0A3-12BB50B6A6F0}</string>
									<ProtectedString name="Source"><![CDATA[local Type = require(script.Parent.Type)

local function createFragment(elements)
	return {
		[Type] = Type.Fragment,
		elements = elements,
	}
end

return createFragment]]></ProtectedString>
									<BinaryString name="Tags"></BinaryString>
								</Properties>
							</Item>
							<Item class="ModuleScript" referent="RBXEE6A35DAA7E94916AA2507B4DDCBDC04">
								<Properties>
									<Content name="LinkedSource"><null></null></Content>
									<string name="Name">createReconciler</string>
									<string name="ScriptGuid">{852627FD-B02E-499D-84FA-1A7D6F62C778}</string>
									<ProtectedString name="Source"><![CDATA[local Type = require(script.Parent.Type)
local ElementKind = require(script.Parent.ElementKind)
local ElementUtils = require(script.Parent.ElementUtils)
local Children = require(script.Parent.PropMarkers.Children)
local Symbol = require(script.Parent.Symbol)
local internalAssert = require(script.Parent.internalAssert)

local config = require(script.Parent.GlobalConfig).get()

local InternalData = Symbol.named("InternalData")

--[[
	The reconciler is the mechanism in Roact that constructs the virtual tree
	that later gets turned into concrete objects by the renderer.

	Roact's reconciler is constructed with the renderer as an argument, which
	enables switching to different renderers for different platforms or
	scenarios.

	When testing the reconciler itself, it's common to use `NoopRenderer` with
	spies replacing some methods. The default (and only) reconciler interface
	exposed by Roact right now uses `RobloxRenderer`.
]]
local function createReconciler(renderer)
	local reconciler
	local mountVirtualNode
	local updateVirtualNode
	local unmountVirtualNode

	--[[
		Unmount the given virtualNode, replacing it with a new node described by
		the given element.

		Preserves host properties, depth, and context from parent.
	]]
	local function replaceVirtualNode(virtualNode, newElement)
		local hostParent = virtualNode.hostParent
		local hostKey = virtualNode.hostKey
		local depth = virtualNode.depth
		local parentContext = virtualNode.parentContext

		unmountVirtualNode(virtualNode)
		local newNode = mountVirtualNode(newElement, hostParent, hostKey, parentContext)

		-- mountVirtualNode can return nil if the element is a boolean
		if newNode ~= nil then
			newNode.depth = depth
		end

		return newNode
	end

	--[[
		Utility to update the children of a virtual node based on zero or more
		updated children given as elements.
	]]
	local function updateChildren(virtualNode, hostParent, newChildElements)
		if config.internalTypeChecks then
			internalAssert(Type.of(virtualNode) == Type.VirtualNode, "Expected arg #1 to be of type VirtualNode")
		end

		local removeKeys = {}

		-- Changed or removed children
		for childKey, childNode in pairs(virtualNode.children) do
			local newElement = ElementUtils.getElementByKey(newChildElements, childKey)
			local newNode = updateVirtualNode(childNode, newElement)

			if newNode ~= nil then
				virtualNode.children[childKey] = newNode
			else
				removeKeys[childKey] = true
			end
		end

		for childKey in pairs(removeKeys) do
			virtualNode.children[childKey] = nil
		end

		-- Added children
		for childKey, newElement in ElementUtils.iterateElements(newChildElements) do
			local concreteKey = childKey
			if childKey == ElementUtils.UseParentKey then
				concreteKey = virtualNode.hostKey
			end

			if virtualNode.children[childKey] == nil then
				local childNode = mountVirtualNode(newElement, hostParent, concreteKey, virtualNode.context)

				-- mountVirtualNode can return nil if the element is a boolean
				if childNode ~= nil then
					childNode.depth = virtualNode.depth + 1
					virtualNode.children[childKey] = childNode
				end
			end
		end
	end

	local function updateVirtualNodeWithChildren(virtualNode, hostParent, newChildElements)
		updateChildren(virtualNode, hostParent, newChildElements)
	end

	local function updateVirtualNodeWithRenderResult(virtualNode, hostParent, renderResult)
		-- TODO: Consider reordering checks (https://github.com/Roblox/roact/issues/200)
		if renderResult == nil
			or typeof(renderResult) == "boolean"
			or Type.of(renderResult) == Type.Element
			or Type.of(renderResult) == Type.Fragment
		then
			updateChildren(virtualNode, hostParent, renderResult)
		else
			error(("%s\n%s"):format(
				"Component returned invalid children:",
				virtualNode.currentElement.source or "<enable element tracebacks>"
			), 0)
		end
	end

	--[[
		Unmounts the given virtual node and releases any held resources.
	]]
	function unmountVirtualNode(virtualNode)
		if config.internalTypeChecks then
			internalAssert(Type.of(virtualNode) == Type.VirtualNode, "Expected arg #1 to be of type VirtualNode")
		end

		local kind = ElementKind.of(virtualNode.currentElement)

		if kind == ElementKind.Host then
			renderer.unmountHostNode(reconciler, virtualNode)
		elseif kind == ElementKind.Function then
			for _, childNode in pairs(virtualNode.children) do
				unmountVirtualNode(childNode)
			end
		elseif kind == ElementKind.Stateful then
			virtualNode.instance:__unmount()
		elseif kind == ElementKind.Portal then
			for _, childNode in pairs(virtualNode.children) do
				unmountVirtualNode(childNode)
			end
		else
			error(("Unknown ElementKind %q"):format(tostring(kind), 2))
		end
	end

	local function updateFunctionVirtualNode(virtualNode, newElement)
		local children = newElement.component(newElement.props)

		updateVirtualNodeWithRenderResult(virtualNode, virtualNode.hostParent, children)

		return virtualNode
	end

	local function updatePortalVirtualNode(virtualNode, newElement)
		local oldElement = virtualNode.currentElement
		local oldTargetHostParent = oldElement.props.target

		local targetHostParent = newElement.props.target

		assert(renderer.isHostObject(targetHostParent), "Expected target to be host object")

		if targetHostParent ~= oldTargetHostParent then
			return replaceVirtualNode(virtualNode, newElement)
		end

		local children = newElement.props[Children]

		updateVirtualNodeWithChildren(virtualNode, targetHostParent, children)

		return virtualNode
	end

	--[[
		Update the given virtual node using a new element describing what it
		should transform into.

		`updateVirtualNode` will return a new virtual node that should replace
		the passed in virtual node. This is because a virtual node can be
		updated with an element referencing a different component!

		In that case, `updateVirtualNode` will unmount the input virtual node,
		mount a new virtual node, and return it in this case, while also issuing
		a warning to the user.
	]]
	function updateVirtualNode(virtualNode, newElement, newState)
		if config.internalTypeChecks then
			internalAssert(Type.of(virtualNode) == Type.VirtualNode, "Expected arg #1 to be of type VirtualNode")
		end
		if config.typeChecks then
			assert(
				Type.of(newElement) == Type.Element or typeof(newElement) == "boolean" or newElement == nil,
				"Expected arg #2 to be of type Element, boolean, or nil"
			)
		end

		-- If nothing changed, we can skip this update
		if virtualNode.currentElement == newElement and newState == nil then
			return virtualNode
		end

		if typeof(newElement) == "boolean" or newElement == nil then
			unmountVirtualNode(virtualNode)
			return nil
		end

		if virtualNode.currentElement.component ~= newElement.component then
			return replaceVirtualNode(virtualNode, newElement)
		end

		local kind = ElementKind.of(newElement)

		local shouldContinueUpdate = true

		if kind == ElementKind.Host then
			virtualNode = renderer.updateHostNode(reconciler, virtualNode, newElement)
		elseif kind == ElementKind.Function then
			virtualNode = updateFunctionVirtualNode(virtualNode, newElement)
		elseif kind == ElementKind.Stateful then
			shouldContinueUpdate = virtualNode.instance:__update(newElement, newState)
		elseif kind == ElementKind.Portal then
			virtualNode = updatePortalVirtualNode(virtualNode, newElement)
		else
			error(("Unknown ElementKind %q"):format(tostring(kind), 2))
		end

		-- Stateful components can abort updates via shouldUpdate. If that
		-- happens, we should stop doing stuff at this point.
		if not shouldContinueUpdate then
			return virtualNode
		end

		virtualNode.currentElement = newElement

		return virtualNode
	end

	--[[
		Constructs a new virtual node but not does mount it.
	]]
	local function createVirtualNode(element, hostParent, hostKey, context)
		if config.internalTypeChecks then
			internalAssert(renderer.isHostObject(hostParent) or hostParent == nil, "Expected arg #2 to be a host object")
			internalAssert(typeof(context) == "table" or context == nil, "Expected arg #4 to be of type table or nil")
		end
		if config.typeChecks then
			assert(hostKey ~= nil, "Expected arg #3 to be non-nil")
			assert(
				Type.of(element) == Type.Element or typeof(element) == "boolean",
				"Expected arg #1 to be of type Element or boolean"
			)
		end

		return {
			[Type] = Type.VirtualNode,
			currentElement = element,
			depth = 1,
			children = {},
			hostParent = hostParent,
			hostKey = hostKey,
			context = context,
			-- This copy of context is useful if the element gets replaced
			-- with an element of a different component type
			parentContext = context,
		}
	end

	local function mountFunctionVirtualNode(virtualNode)
		local element = virtualNode.currentElement

		local children = element.component(element.props)

		updateVirtualNodeWithRenderResult(virtualNode, virtualNode.hostParent, children)
	end

	local function mountPortalVirtualNode(virtualNode)
		local element = virtualNode.currentElement

		local targetHostParent = element.props.target
		local children = element.props[Children]

		assert(renderer.isHostObject(targetHostParent), "Expected target to be host object")

		updateVirtualNodeWithChildren(virtualNode, targetHostParent, children)
	end

	--[[
		Constructs a new virtual node and mounts it, but does not place it into
		the tree.
	]]
	function mountVirtualNode(element, hostParent, hostKey, context)
		if config.internalTypeChecks then
			internalAssert(renderer.isHostObject(hostParent) or hostParent == nil, "Expected arg #2 to be a host object")
			internalAssert(typeof(context) == "table" or context == nil, "Expected arg #4 to be of type table or nil")
		end
		if config.typeChecks then
			assert(hostKey ~= nil, "Expected arg #3 to be non-nil")
			assert(
				Type.of(element) == Type.Element or typeof(element) == "boolean",
				"Expected arg #1 to be of type Element or boolean"
			)
		end

		-- Boolean values render as nil to enable terse conditional rendering.
		if typeof(element) == "boolean" then
			return nil
		end

		local kind = ElementKind.of(element)

		local virtualNode = createVirtualNode(element, hostParent, hostKey, context)

		if kind == ElementKind.Host then
			renderer.mountHostNode(reconciler, virtualNode)
		elseif kind == ElementKind.Function then
			mountFunctionVirtualNode(virtualNode)
		elseif kind == ElementKind.Stateful then
			element.component:__mount(reconciler, virtualNode)
		elseif kind == ElementKind.Portal then
			mountPortalVirtualNode(virtualNode)
		else
			error(("Unknown ElementKind %q"):format(tostring(kind), 2))
		end

		return virtualNode
	end

	--[[
		Constructs a new Roact virtual tree, constructs a root node for
		it, and mounts it.
	]]
	local function mountVirtualTree(element, hostParent, hostKey)
		if config.typeChecks then
			assert(Type.of(element) == Type.Element, "Expected arg #1 to be of type Element")
			assert(renderer.isHostObject(hostParent) or hostParent == nil, "Expected arg #2 to be a host object")
		end

		if hostKey == nil then
			hostKey = "RoactTree"
		end

		local tree = {
			[Type] = Type.VirtualTree,
			[InternalData] = {
				-- The root node of the tree, which starts into the hierarchy of
				-- Roact component instances.
				rootNode = nil,
				mounted = true,
			},
		}

		tree[InternalData].rootNode = mountVirtualNode(element, hostParent, hostKey)

		return tree
	end

	--[[
		Unmounts the virtual tree, freeing all of its resources.

		No further operations should be done on the tree after it's been
		unmounted, as indicated by its the `mounted` field.
	]]
	local function unmountVirtualTree(tree)
		local internalData = tree[InternalData]
		if config.typeChecks then
			assert(Type.of(tree) == Type.VirtualTree, "Expected arg #1 to be a Roact handle")
			assert(internalData.mounted, "Cannot unmounted a Roact tree that has already been unmounted")
		end

		internalData.mounted = false

		if internalData.rootNode ~= nil then
			unmountVirtualNode(internalData.rootNode)
		end
	end

	--[[
		Utility method for updating the root node of a virtual tree given a new
		element.
	]]
	local function updateVirtualTree(tree, newElement)
		local internalData = tree[InternalData]
		if config.typeChecks then
			assert(Type.of(tree) == Type.VirtualTree, "Expected arg #1 to be a Roact handle")
			assert(Type.of(newElement) == Type.Element, "Expected arg #2 to be a Roact Element")
		end

		internalData.rootNode = updateVirtualNode(internalData.rootNode, newElement)

		return tree
	end

	reconciler = {
		mountVirtualTree = mountVirtualTree,
		unmountVirtualTree = unmountVirtualTree,
		updateVirtualTree = updateVirtualTree,

		createVirtualNode = createVirtualNode,
		mountVirtualNode = mountVirtualNode,
		unmountVirtualNode = unmountVirtualNode,
		updateVirtualNode = updateVirtualNode,
		updateVirtualNodeWithChildren = updateVirtualNodeWithChildren,
		updateVirtualNodeWithRenderResult = updateVirtualNodeWithRenderResult,
	}

	return reconciler
end

return createReconciler]]></ProtectedString>
									<BinaryString name="Tags"></BinaryString>
								</Properties>
							</Item>
							<Item class="ModuleScript" referent="RBX17B7F11724A0416D91A40A66F3F2208B">
								<Properties>
									<Content name="LinkedSource"><null></null></Content>
									<string name="Name">createReconcilerCompat</string>
									<string name="ScriptGuid">{DAC16CAB-34CD-4B96-AA43-8B622E09551F}</string>
									<ProtectedString name="Source"><![CDATA[--[[
	Contains deprecated methods from Reconciler. Broken out so that removing
	this shim is easy -- just delete this file and remove it from init.
]]

local Logging = require(script.Parent.Logging)

local reifyMessage = [[
Roact.reify has been renamed to Roact.mount and will be removed in a future release.
Check the call to Roact.reify at:
]]

local teardownMessage = [[
Roact.teardown has been renamed to Roact.unmount and will be removed in a future release.
Check the call to Roact.teardown at:
]]

local reconcileMessage = [[
Roact.reconcile has been renamed to Roact.update and will be removed in a future release.
Check the call to Roact.reconcile at:
]]

local function createReconcilerCompat(reconciler)
	local compat = {}

	function compat.reify(...)
		Logging.warnOnce(reifyMessage)

		return reconciler.mountVirtualTree(...)
	end

	function compat.teardown(...)
		Logging.warnOnce(teardownMessage)

		return reconciler.unmountVirtualTree(...)
	end

	function compat.reconcile(...)
		Logging.warnOnce(reconcileMessage)

		return reconciler.updateVirtualTree(...)
	end

	return compat
end

return createReconcilerCompat]]></ProtectedString>
									<BinaryString name="Tags"></BinaryString>
								</Properties>
							</Item>
							<Item class="ModuleScript" referent="RBXA42A2843E33D492699E415046D44F00B">
								<Properties>
									<Content name="LinkedSource"><null></null></Content>
									<string name="Name">createRef</string>
									<string name="ScriptGuid">{B916E95C-B380-464B-9F9C-9E44BD1C58BF}</string>
									<ProtectedString name="Source"><![CDATA[--[[
	A ref is nothing more than a binding with a special field 'current'
	that maps to the getValue method of the binding
]]
local Binding = require(script.Parent.Binding)

local function createRef()
	local binding, _ = Binding.create(nil)

	local ref = {}

	--[[
		A ref is just redirected to a binding via its metatable
	]]
	setmetatable(ref, {
		__index = function(self, key)
			if key == "current" then
				return binding:getValue()
			else
				return binding[key]
			end
		end,
		__newindex = function(self, key, value)
			if key == "current" then
				error("Cannot assign to the 'current' property of refs", 2)
			end

			binding[key] = value
		end,
		__tostring = function(self)
			return ("RoactRef(%s)"):format(tostring(binding:getValue()))
		end,
	})

	return ref
end

return createRef]]></ProtectedString>
									<BinaryString name="Tags"></BinaryString>
								</Properties>
							</Item>
							<Item class="ModuleScript" referent="RBX597FFD3961134C63B93B429ACDEF42E5">
								<Properties>
									<Content name="LinkedSource"><null></null></Content>
									<string name="Name">createSignal</string>
									<string name="ScriptGuid">{5EA53DA0-5DDB-42E8-9AD1-D9CB34991D5E}</string>
									<ProtectedString name="Source"><![CDATA[--[[
	This is a simple signal implementation that has a dead-simple API.

		local signal = createSignal()

		local disconnect = signal:subscribe(function(foo)
			print("Cool foo:", foo)
		end)

		signal:fire("something")

		disconnect()
]]

local function addToMap(map, addKey, addValue)
	local new = {}

	for key, value in pairs(map) do
		new[key] = value
	end

	new[addKey] = addValue

	return new
end

local function removeFromMap(map, removeKey)
	local new = {}

	for key, value in pairs(map) do
		if key ~= removeKey then
			new[key] = value
		end
	end

	return new
end

local function createSignal()
	local connections = {}

	local function subscribe(self, callback)
		assert(typeof(callback) == "function", "Can only subscribe to signals with a function.")

		local connection = {
			callback = callback,
		}

		connections = addToMap(connections, callback, connection)

		local function disconnect()
			assert(not connection.disconnected, "Listeners can only be disconnected once.")

			connection.disconnected = true
			connections = removeFromMap(connections, callback)
		end

		return disconnect
	end

	local function fire(self, ...)
		for callback, connection in pairs(connections) do
			if not connection.disconnected then
				callback(...)
			end
		end
	end

	return {
		subscribe = subscribe,
		fire = fire,
	}
end

return createSignal]]></ProtectedString>
									<BinaryString name="Tags"></BinaryString>
								</Properties>
							</Item>
							<Item class="ModuleScript" referent="RBXE05B94396A6846ED89DA1F3851816239">
								<Properties>
									<Content name="LinkedSource"><null></null></Content>
									<string name="Name">createSpy</string>
									<string name="ScriptGuid">{ADCCDECC-EC8E-4FE5-9EB8-A0D2CFDB08F3}</string>
									<ProtectedString name="Source"><![CDATA[--[[
	A utility used to create a function spy that can be used to robustly test
	that functions are invoked the correct number of times and with the correct
	number of arguments.

	This should only be used in tests.
]]

local assertDeepEqual = require(script.Parent.assertDeepEqual)

local function createSpy(inner)
	local self = {
		callCount = 0,
		values = {},
		valuesLength = 0,
	}

	self.value = function(...)
		self.callCount = self.callCount + 1
		self.values = {...}
		self.valuesLength = select("#", ...)

		if inner ~= nil then
			return inner(...)
		end
	end

	self.assertCalledWith = function(_, ...)
		local len = select("#", ...)

		if self.valuesLength ~= len then
			error(("Expected %d arguments, but was called with %d arguments"):format(
				self.valuesLength,
				len
			), 2)
		end

		for i = 1, len do
			local expected = select(i, ...)

			assert(self.values[i] == expected, "value differs")
		end
	end

	self.assertCalledWithDeepEqual = function(_, ...)
		local len = select("#", ...)

		if self.valuesLength ~= len then
			error(("Expected %d arguments, but was called with %d arguments"):format(
				self.valuesLength,
				len
			), 2)
		end

		for i = 1, len do
			local expected = select(i, ...)

			assertDeepEqual(self.values[i], expected)
		end
	end

	self.captureValues = function(_, ...)
		local len = select("#", ...)
		local result = {}

		assert(self.valuesLength == len, "length of expected values differs from stored values")

		for i = 1, len do
			local key = select(i, ...)
			result[key] = self.values[i]
		end

		return result
	end

	setmetatable(self, {
		__index = function(_, key)
			error(("%q is not a valid member of spy"):format(key))
		end,
	})

	return self
end

return createSpy]]></ProtectedString>
									<BinaryString name="Tags"></BinaryString>
								</Properties>
							</Item>
							<Item class="ModuleScript" referent="RBXBEFFB5BE9D9443538392B19732C6D76F">
								<Properties>
									<Content name="LinkedSource"><null></null></Content>
									<string name="Name">getDefaultInstanceProperty</string>
									<string name="ScriptGuid">{E9079B5A-90CE-4DE3-BA76-6CDFF5D03AEE}</string>
									<ProtectedString name="Source"><![CDATA[--[[
	Attempts to get the default value of a given property on a Roblox instance.

	This is used by the reconciler in cases where a prop was previously set on a
	primitive component, but is no longer present in a component's new props.

	Eventually, Roblox might provide a nicer API to query the default property
	of an object without constructing an instance of it.
]]

local Symbol = require(script.Parent.Symbol)

local Nil = Symbol.named("Nil")
local _cachedPropertyValues = {}

local function getDefaultInstanceProperty(className, propertyName)
	local classCache = _cachedPropertyValues[className]

	if classCache then
		local propValue = classCache[propertyName]

		-- We have to use a marker here, because Lua doesn't distinguish
		-- between 'nil' and 'not in a table'
		if propValue == Nil then
			return true, nil
		end

		if propValue ~= nil then
			return true, propValue
		end
	else
		classCache = {}
		_cachedPropertyValues[className] = classCache
	end

	local created = Instance.new(className)
	local ok, defaultValue = pcall(function()
		return created[propertyName]
	end)

	created:Destroy()

	if ok then
		if defaultValue == nil then
			classCache[propertyName] = Nil
		else
			classCache[propertyName] = defaultValue
		end
	end

	return ok, defaultValue
end

return getDefaultInstanceProperty]]></ProtectedString>
									<BinaryString name="Tags"></BinaryString>
								</Properties>
							</Item>
							<Item class="ModuleScript" referent="RBX558EF7F76A9D4340885AF10BE6F28B92">
								<Properties>
									<Content name="LinkedSource"><null></null></Content>
									<string name="Name">internalAssert</string>
									<string name="ScriptGuid">{F4012148-5BD7-47CF-AB40-32794760268A}</string>
									<ProtectedString name="Source"><![CDATA[local function internalAssert(condition, message)
	if not condition then
		error(message .. " (This is probably a bug in Roact!)", 3)
	end
end

return internalAssert]]></ProtectedString>
									<BinaryString name="Tags"></BinaryString>
								</Properties>
							</Item>
							<Item class="ModuleScript" referent="RBXC47954FC6C6E46FAB7B0FAC0338E1DE0">
								<Properties>
									<Content name="LinkedSource"><null></null></Content>
									<string name="Name">invalidSetStateMessages</string>
									<string name="ScriptGuid">{A5102E18-3CDF-4166-97CD-5569854EA363}</string>
									<ProtectedString name="Source"><![CDATA[--[[
	These messages are used by Component to help users diagnose when they're
	calling setState in inappropriate places.

	The indentation may seem odd, but it's necessary to avoid introducing extra
	whitespace into the error messages themselves.
]]
local ComponentLifecyclePhase = require(script.Parent.ComponentLifecyclePhase)

local invalidSetStateMessages = {}

invalidSetStateMessages[ComponentLifecyclePhase.WillUpdate] = [[
setState cannot be used in the willUpdate lifecycle method.
Consider using the didUpdate method instead, or using getDerivedStateFromProps.

Check the definition of willUpdate in the component %q.]]

invalidSetStateMessages[ComponentLifecyclePhase.WillUnmount] = [[
setState cannot be used in the willUnmount lifecycle method.
A component that is being unmounted cannot be updated!

Check the definition of willUnmount in the component %q.]]

invalidSetStateMessages[ComponentLifecyclePhase.ShouldUpdate] = [[
setState cannot be used in the shouldUpdate lifecycle method.
shouldUpdate must be a pure function that only depends on props and state.

Check the definition of shouldUpdate in the component %q.]]

invalidSetStateMessages[ComponentLifecyclePhase.Render] = [[
setState cannot be used in the render method.
render must be a pure function that only depends on props and state.

Check the definition of render in the component %q.]]

invalidSetStateMessages["default"] = [[
setState can not be used in the current situation, because Roact doesn't know
which part of the lifecycle this component is in.

This is a bug in Roact.
It was triggered by the component %q.
]]

return invalidSetStateMessages]]></ProtectedString>
									<BinaryString name="Tags"></BinaryString>
								</Properties>
							</Item>
							<Item class="ModuleScript" referent="RBX06998FA271834813AA65E779E4F9A8AA">
								<Properties>
									<Content name="LinkedSource"><null></null></Content>
									<string name="Name">oneChild</string>
									<string name="ScriptGuid">{282F5EBB-0FD3-462B-B578-2A7A30F8AD76}</string>
									<ProtectedString name="Source"><![CDATA[--[[
	Retrieves at most one child from the children passed to a component.

	If passed nil or an empty table, will return nil.

	Throws an error if passed more than one child.
]]
local function oneChild(children)
	if not children then
		return nil
	end

	local key, child = next(children)

	if not child then
		return nil
	end

	local after = next(children, key)

	if after then
		error("Expected at most child, had more than one child.", 2)
	end

	return child
end

return oneChild]]></ProtectedString>
									<BinaryString name="Tags"></BinaryString>
								</Properties>
							</Item>
							<Item class="ModuleScript" referent="RBX270FF154C9CB418BAD4EF269DF506A2E">
								<Properties>
									<Content name="LinkedSource"><null></null></Content>
									<string name="Name">strict</string>
									<string name="ScriptGuid">{57E5743C-5F12-4D76-815D-197EDBDF5AEF}</string>
									<ProtectedString name="Source"><![CDATA[local function strict(t, name)
	name = name or tostring(t)

	return setmetatable(t, {
		__index = function(self, key)
			local message = ("%q (%s) is not a valid member of %s"):format(
				tostring(key),
				typeof(key),
				name
			)

			error(message, 2)
		end,

		__newindex = function(self, key, value)
			local message = ("%q (%s) is not a valid member of %s"):format(
				tostring(key),
				typeof(key),
				name
			)

			error(message, 2)
		end,
	})
end

return strict]]></ProtectedString>
									<BinaryString name="Tags"></BinaryString>
								</Properties>
							</Item>
						</Item>
					</Item>
				</Item>
				<Item class="ModuleScript" referent="RBX235EC29F475F4ACBAD49423CEA3AFFBE">
					<Properties>
						<Content name="LinkedSource"><null></null></Content>
						<string name="Name">services</string>
						<string name="ScriptGuid">{76F1DD58-23E9-41B6-8EC6-FFB00034B5D4}</string>
						<ProtectedString name="Source"><![CDATA[return setmetatable({}, {
    __index = function(self, serviceName)
        local service = game:GetService(serviceName);
        self[serviceName] = service;
        return service;
    end;
})]]></ProtectedString>
						<BinaryString name="Tags"></BinaryString>
					</Properties>
				</Item>
				<Item class="ModuleScript" referent="RBXAC426B93875F48B8BA9B991E475C41DE">
					<Properties>
						<Content name="LinkedSource"><null></null></Content>
						<string name="Name">tween</string>
						<string name="ScriptGuid">{79F06B1D-1ECE-4547-A1D9-7FE892FE7F0E}</string>
						<ProtectedString name="Source"><![CDATA[local Lerps = require(assert(script.Parent:FindFirstChild("lerp-functions"), "[@rbxts/tween] Please install @rbxts/lerp-functions to use this library."))

local Tween = {
	Running = false;
	ElapsedTime = 0;
}
Tween.__index = Tween

local RunService = game:GetService("RunService")
local Heartbeat = RunService.Heartbeat
local RenderStepped = RunService.RenderStepped

function Tween:Play()
	if not self.Running then
		local RenderEvent

		if self.ValueType == "CFrame" then
			RenderEvent = RenderStepped
		else
			RenderEvent = Heartbeat
		end

		self.Connection = RenderEvent:Connect(self.Interpolator)
		self.Running = true
	end

	return self
end

function Tween:Pause()
	if self.Running then
		self.Connection:Disconnect()
		self.Running = false
	end

	return self
end

function Tween:Cancel()
	self.ElapsedTime = 0
	return self:Pause()
end

function Tween:Wait()
	local RenderEvent

	if self.ValueType == "CFrame" then
		RenderEvent = RenderStepped
	else
		RenderEvent = Heartbeat
	end

	while self.Running do RenderEvent:Wait() end
	return self
end

local function MakeTween(Duration, EasingFunction, Callback, InitialValue, EndValue, v1, v2)
	if InitialValue == nil then
		InitialValue = 0
		EndValue = 1
	end

	local ValueType = typeof(InitialValue)
	local LerpFunction = Lerps[ValueType](InitialValue, EndValue)

	local self = setmetatable({
		Duration = Duration;
		ValueType = ValueType;
	}, Tween)

	function self.Interpolator(Step)
		local ElapsedTime = self.ElapsedTime + Step
		self.ElapsedTime = ElapsedTime

		if Duration > ElapsedTime then
			-- Because of the way doubles are implemented,
			-- they can hold more unique values between 0 and 1 than any other numbers.
			-- To take advantage of this precision, we shouldn't try to get smart about
			-- changing the beginning/change parameters here
			Callback(LerpFunction(EasingFunction(ElapsedTime, 0, 1, Duration, v1, v2)))
		else
			Callback(EndValue)
			self:Pause()
		end
	end

	return self:Play()
end

return {
	Tween = MakeTween;
	default = MakeTween;
}
]]></ProtectedString>
						<BinaryString name="Tags"></BinaryString>
					</Properties>
				</Item>
			</Item>
		</Item>
	</Item>
	<Item class="LuaWebService" referent="RBXE43DC4C614C040A7BFC7C0DB28CBCEA7">
		<Properties>
			<string name="Name">Instance</string>
			<BinaryString name="Tags"></BinaryString>
		</Properties>
	</Item>
	<Item class="Lighting" referent="RBX13A7E6B2299146B8AC475F2616186EF3">
		<Properties>
			<Color3 name="Ambient">
				<R>0.5</R>
				<G>0.5</G>
				<B>0.5</B>
			</Color3>
			<float name="Brightness">1</float>
			<Color3 name="ColorShift_Bottom">
				<R>0</R>
				<G>0</G>
				<B>0</B>
			</Color3>
			<Color3 name="ColorShift_Top">
				<R>0</R>
				<G>0</G>
				<B>0</B>
			</Color3>
			<float name="ExposureCompensation">0</float>
			<Color3 name="FogColor">
				<R>0.75</R>
				<G>0.75</G>
				<B>0.75</B>
			</Color3>
			<float name="FogEnd">100000</float>
			<float name="FogStart">0</float>
			<float name="GeographicLatitude">41.7332993</float>
			<bool name="GlobalShadows">false</bool>
			<bool name="LegacyOutlines">false</bool>
			<string name="Name">Lighting</string>
			<Color3 name="OutdoorAmbient">
				<R>0.5</R>
				<G>0.5</G>
				<B>0.5</B>
			</Color3>
			<bool name="Outlines">true</bool>
			<float name="ShadowSoftness">0.5</float>
			<BinaryString name="Tags"></BinaryString>
			<token name="Technology">2</token>
			<string name="TimeOfDay">14:00:00</string>
		</Properties>
	</Item>
	<Item class="HttpService" referent="RBX07B5875EFBFB47E4839300E7DB06772F">
		<Properties>
			<bool name="HttpEnabled">true</bool>
			<string name="Name">HttpService</string>
			<BinaryString name="Tags"></BinaryString>
		</Properties>
	</Item>
	<Item class="TestService" referent="RBX85DE4626F0F8430AB326760A6710ECED">
		<Properties>
			<bool name="AutoRuns">true</bool>
			<string name="Description"></string>
			<bool name="ExecuteWithStudioRun">false</bool>
			<bool name="Is30FpsThrottleEnabled">true</bool>
			<bool name="IsPhysicsEnvironmentalThrottled">true</bool>
			<bool name="IsSleepAllowed">true</bool>
			<string name="Name">TestService</string>
			<int name="NumberOfPlayers">0</int>
			<double name="SimulateSecondsLag">0</double>
			<BinaryString name="Tags"></BinaryString>
			<double name="Timeout">10</double>
		</Properties>
	</Item>
	<Item class="StudioData" referent="RBX10F9E7F6AE284CF8846BF4BAA27DDCB4">
		<Properties>
			<string name="Name">StudioData</string>
			<int64 name="SrcPlaceId">3737267249</int64>
			<int64 name="SrcUniverseId">1294058524</int64>
			<BinaryString name="Tags"></BinaryString>
		</Properties>
	</Item>
</roblox>